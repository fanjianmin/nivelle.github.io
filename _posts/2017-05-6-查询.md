---
layout: post
title:  "索引学习之查询性能优化"
date:   2017-04-23 00:06:05
categories: 技术
tags: mysql
excerpt: 查询性能优化
---


* content
{:toc}



# 查询优化

## 查询生命周期的定义：
从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回给客户端。
其中执行包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组。

## 慢查询的两个原因：
1. 确认应用程序是否在检索大量超过需要的数据，通常意味着访问了太多的行，但有时候也可能是访问了太多的列
2. 确认MYSQL服务器是否在分析大量超过需要的数据行

### 典型案例
1.常见错误误以为mysql只返回需要的数据，实际上MySQL却是先返回全部结果集再进行计算。最有效的避免方法是使用limit

2.多表关联是返回全部列，应该只取需要的列。

3.总是取出全部列。取出全部列会让优化器无法完成索引覆盖扫描这类优化，还会为服务器带来额外的I/O\，内存和CPU的消耗。

4.重复查询相同的数据。例如在用户评论的地方需要查询用户头像的url，那么用户多次评论的时候，可能会反复查询这个数据。比较好的方案是，当初查询时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好。

#### 如果发现查询需要扫描大量的数据但是只返回少数的行，那么可以尝试下面的技巧去优化：

- 使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果。
- 改变库表借口（**？？？？**，这个是啥回头弄明白）
- 重构查询方式，优化器能够以更优化的方式执行这个查询。


## 重构查询方式

1.关于切分查询：

有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。例如删除旧数据，定期删除大量数据时如果用一个大语句的话，容易造成一次锁住很多数据，占满整个事物日志、耗尽系统资源、阻塞很多小的单很重要的查询。同时，如果每次删除完后，暂停一下再做下一次删除，这样也可以将服务器上原本一次的压力分散到一个很长的时间段中，大大降低了对服务器的影响，还可以大大减少删除时锁的持有时间。

2.分解关联查询

很多高性能的应用都会对关联查询进行分解，简单地，可以对每一个表进行一次单表查询，然后将结果应用程序中进行关联。

**这么做的优点**：

- 让缓存更有效。许多应用程序可以方便地缓存单表查询对应的结果对象。
- 查询分解后，执行单个查询可以减少锁竞争。
- 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可拓展。
- 查询效率本身也可能会有很大提升。
- 减少冗余记录的查询，在应用层只需查询一次，而在数据库中关联查询可能会重复地访问同一部分数据，

## 执行查询的基础

MySQL执行一次查询的流程如图：
![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

###  通信协议

MySQL客户端/服务器通信协议是“半双工”的，这意味着，在任何一个时刻，要么由服务器向客户端发送数据，要么客户端向服务器发送数据，着俩动作不能同时发生。所以，我们无法将一个消息切成小块独立来发送。

客户端用一个单独的数据包将查询传递给服务器，这也是为什么查询的语句很长的时候，参数max_allowed_packet就特别重要了。一旦客户端发送了请求，它能做的事情就是等待结果了。

相反，服务器响应给用户的数据通常很多，有多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整接受整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这也是在必要的时候，一定要加上limit限制的原因。

-----
更新中。。。。
