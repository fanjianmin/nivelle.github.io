---
layout: post
title:  "Servlet3实现请求隔离"
date:   2017-07-01 00:06:05
categories: 架构
tags: servlet3
excerpt: 基于Servlet3实现请求隔离
---

* content
{:toc}


### Servlet3.0实现请求隔离的好处

Tomcat在收到HTTP请求之后会按照如下流程处理请求:

- 容器负责接收并解析请求为HttpServletRequest
- 然后交给Servlet进行业务处理
- 最后通过HttpServletResponse写出响应

在Servlet2.x规范中,所有这些处理都是同步进行的,也就是说必须在一个线程中完成接收请求,业务处理到响应,在请求结束是,会同步进行请求回收,也就是说请求解析,业务处理和响应必须在一个线程内完成,不能跨线程界限.

异步化之后得到的好处如下:

- 基于NIO能处理更高的并发连接数
- 请求解析和业务处理线程池分离
- 根据业务重要性对业务分级,并分级线程池
- 对业务线程池进行监控,运维,降级处理


#### 请求解析页业务处理线程池分离

引入Servlet3.0之前我们的线程模型是这样的:

![image](http://7xpuj1.com1.z0.glb.clouddn.com/servlet2.0.png)

升级Servlet3之后,我们的线程模型可以改造为如下样子:

![image](http://7xpuj1.com1.z0.glb.clouddn.com/servlet3%E6%A8%A1%E5%9E%8B.png)

请求解析使用Tomcat单线程,而解析完成后将请求扔到业务队列中,由业务线程池进行处理,这种处理方式可以得到如下好处:

- 根据业务重要性对业务进行分级,然后根据分级定义线程池
- 可以拿到业务线程池,可以进行很多操作,比如监控,降级

#### 业务线程池隔离

在一个系统的发展期间,我们一般吧很多服务放到一个系统中进行处理,比如库存服务,图书相关服务,延保服务等;我们根据其重要性对业务分级和做限制

- 可以把业务分为核心业务级别和非核心业务级别
- 为不同级别的业务定义不同的线程池,线程池之间是隔离的
- 根据业务量定义各个级别线程池大小




![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB.png)
