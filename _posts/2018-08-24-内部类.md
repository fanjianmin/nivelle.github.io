---
layout: post
title:  "内部类"
date:   2018-08-24 01:06:05
categories: 知识点
tags: 内部类
excerpt: 内部类详解
---


* content
{:toc}

#### 内部类的好处

- 内部类可以访问该类定义所在作用域的数据


  当外部类的对象创建了一个内部类的对象时，内部类对象必定会秘密捕获一个指向外部类对象的引用，然后访问外部类的成员时，就是用那个引用来选择外围类的成员的。当然这些编辑器已经帮我们处理了。


- 内部类可以对同一包中的其他类隐藏起来。


  外部类即普通的类不能使用 private protected 访问权限符来修饰的,而内部类则可以使用 private 和 protected 来修饰.这看起来没什么作用，但是当内部类实现某个接口的时候，在进行向上转型，对外部来说，就完全隐藏了接口的实现了。
  
  
- 内部类可以实现java单继承的缺陷
- 通过匿名内部类来“优化”简单的接口实现

#### 内部类与外部类的关系

- 对于非静态内部类，内部类的创建依赖外部类的实例对象，在没有外部类实例之前是无法创建内部类的；



- 内部类是一个相对独立的实体，与外部类不是is-a关系：

  1. 一个外部类可以拥有多个内部类对象，而他们之间没有任何关系，是
  2. 独立的个体。
  2. 从编译结果来看，内部类被表现为 「外部类$内部类.class 」，所以对于虚拟机来说他个一个单独的类来说没什么区别。但是我们知道他们是有关系的，因为内部类默认持有一个外部类的引用。

- 创建内部类的**时刻**并不依赖于外部类的创建。

创建一个外部类的时候不一定要创建这个内部类

#### 内部类的分类

##### 静态内部类和非静态内部类的区别

- 静态内部类可以有静态成员，而非静态内部类则不能有静态成员；
- 静态内部类可以访问外部类的静态变量，而不可访问外部类的非静态变量；
- 非静态内部类的非静态成员可以访问外部类的非静态变量；
- 静态内部类的创建不依赖于外部类，而非静态内部类必须依赖于外部类的创建而创建


#### 局部内部类

如果一个内部类只在一个方法中使用到了，那么我们可以将这个类定义在方法内部，这种内部类被称为局部内部类。其作用域仅限于该方法。

- 局部内类不允许使用访问权限修饰符 public private protected 均不允许
- 局部内部类对外完全隐藏，除了创建这个类的方法可以访问它其他的地方是不允许访问的。
- 局部内部类与成员内部类不同之处是他可以引用成员变量，但该成员必须声明为 final，并内部不允许修改该变量的值。

#### 匿名内部类

- 匿名内部类是没有访问修饰符的
- 匿名内部类必须继承一个抽象类或者实现一个接口
- 匿名内部类中不能存在任何静态成员或方法
- 匿名内部类是没有构造方法的，因为它没有类名
- 与局部内部相同匿名内部类也可以引用局部变量，此变量也必须声明为 final

##### 为什么局部变量需要final修饰呢

原因是：因为局部变量和匿名内部类的生命周期不同。

##### 内部类会造成程序的内存泄漏


- 如果一个匿名内部类没有被任何引用持有，那么匿名内部类对象用完就有机会被回收。

- 如果内部类仅仅只是在外部类中被引用，当外部类的不再被引用时，外部类和内部类就可以都被GC回收
- 如果当内部类的引用被外部类以外的其他类引用时，就会造成内部类和外部类无法被GC回收的情况，即使外部类没有被引用，因为内部类持有指向外部类的引用）。
