---
layout: post
title:  "java容易忽略的基础知识"
date:   2017-06-10 00:06:05
categories: 技术
tags: java
excerpt: java
author: nivelle
---


* content
{:toc}


#### 奇数性

java对取余操作(%)的定义产生的后果。该操作符被定义为对所有的int数值a和所有的非零数值b,都满足下面恒等式：

```
(a/b)*b+(a%b)==a
```
与java的截尾整数正常操作符号相结合时，意味着：当取余操作返回一个非零的结果时，它与做操作数具有相同的正负符号。

正确做法：

```
public static bolean isOdd(int i){
    return i%2 !=0;
}

```
或者：

```
pulic static boolean isOdd(int i){
    return (i&1)!=0
}
```

#### 找零

```
public class Change{
  public static void main(String args[]){
    System.out.println(2.00-1.10);
  }
}
```

问题在于1.1这个数字不能被精确表示为一个double,因此被表示为最接近它的double值。然后2减去的就是这个值。

浮点运算在一个范围很广的值域上提供了很好的近似，但是通常不能产生精确的的结果。二进制浮点数对于货币计算是非常不合适的，因为它不可能将0.1或者10的其他任何次负幂，精确表示为一个有限长度的二进制小数。

**解决方法：**

- 解决该问题的一种方式是使用某种整数类型，例如int或long,并且以分为单位来执行计算。如果采纳了次路线,请确保该整数类型大到足以表示程序中将要用的所有值。

- 使用执行精确小数运算的BigDecimal。一定要用BigDecimal(String)构造器，而不使用BigDecimal(double)。后一个构造器将用它的参数的精确值来创建一个实例。例如new Bigdecimal(.1),它将返回一个BigDecimal,也即0.1000000000000000055511151231257827021181583404541015625
正确使用BigDecimal就可以正确打印出期望值0.90：

```
 System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10")));

```

注意：在需要精确答案的地方，要避免使用float和double；对于货币计算，要使用int、long或者BigDecimal。

####  长整除

被除数表示一天里的微妙数，而除数表示一天里的毫秒数：

```
public class LongDivision {
  public static void main(String[] args) {
    final long MICROS_PER_DAY=24*60*60*1000*1000;
    final long MILLIS_PER_DAY=24*60*60*1000;
    System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
  }
}
```
问题产生的原因：MICROS_PER_DAY的计算溢出了。虽然计算结果适合放入到long中，但是这个乘积并不适合放入int中。这个计算完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升为long.而此时已经太迟：计算已经溢出。从int提升为long是一种拓宽原生类型转换，他保留了不正确的数值。这个值之后被MILLIS_PER_DAY整除，而MILLIS_PER_DAY的计算是正确的，因为它适合int运算。

java不具有目标确定类型的特性，这时一种语言特性，其含义是指存储结果的变量类型会影响计算所使用的类型。

修正：

```
public class LongDivision {
  public static void main(String[] args) {
    final long MICROS_PER_DAY=24L*60*60*1000*1000;
    final long MILLIS_PER_DAY=24L*60*60*1000;
    System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
  }
}
```

当在操作很大的数字时，千万要防止溢出。即使用来保存结果的变量已经足够大，也不意味着要产生结果的计算具有正确的类型。

#### 初级问题

在long类型字面量中，一定要用大写的L,千万不要用小写的l。

#### 十六进制的趣事public class JoyOfHex {
  public static void main(String[] args) {
    System.out.println(Long.toHexString(0x100000000L +0xcafebbe));
  }
}


```
public class JoyOfHex {
  public static void main(String[] args) {
    System.out.println(Long.toHexString(0x100000000L +0xcafebbe));
  }
}


```
十进制字面量都是正的，而十六进制或是八进制字面量并不具备这个属性。如果十六进制和八进制字面量的最高为被置位了，所以它是一个负数。该程序执行的加法是混合类型的计算：左操作数是long类型，而右操作数是int。为了执行计算，java将int类型的数值用拓宽原生类型转换提升为long类型，然后对两个long类型数值相加。因为int是有符号的整数类型，所以这个转换执行的符号拓展：它将负的int类型数值提升为一个在数值上相等的long类型数值，然后对两个long类型数值相加。因为int是有符号的整数类型，所以这个转换执行的是符号拓展：它将负的int类型数值提升为一个在数值上相等的long类型数值。


解决方法：

避免混合类型的计算。


#### java原生类型

java中，数据类型分为基本数据类型和引用类型。java不是纯面向对象的语言，不纯的地方就是这些基本数据类型不是对象

- 基本类型的存储空间。byte-8位，short-16位，int-32位，long-64位，float-32位，double-64位。这六种数字类型都是有符号的。固定的存储空间正是java可移植性、跨平台的原因之一。

- 使用公式-2的（位数-1）次幂到2的（位数-1）次幂-1确定整数类型的范围（byte、short、int、long）

- char是16位Unicode字符或者是16位无符号整数，范围从0到65535。即便如此，可以强制转换非法的数据，如char c1=(chr)10000; char c2=(char)-200

- 整数有八进制（以0开头的整数）、十进制、十六进制（以0x或0X开头的整数）表示。

- char可以用单引号表示单个字符，如‘符’。也可以用unicode值‘ucafe’(四位十六进制数)。

- 默认的浮点类型是双精度（double）,要想一个float必须在浮点数后面加F或者f。如：float pi =3.14;是错误的。

- 默认的整数类型是int型，要想使用长整型可在后面加“l”或“L”,如：1000L。

- float可以精确到7位有效数字，第8位的数字时第9位数字四舍五入取得的;double可以精确到16位有效数字，第17位的数字时第18位数字四舍五入上取得的。

- java为所有的成员变量提供了默认初始化：byte\short\int\long-0 \float-0.0f \double-0.0\boolean-false\char-'u0000',特别地对象应用全被初始化为null。

- 基本类型之间的转化。java的类型检查很严格，从低精度转化到高精度是不需要显式转换的，doule d=123;但是反过来，进行窄化转换，由高精度向低精度转换，则必须使用强制类型转化。

浮点型转化为整型时,不进行四舍五入，直接截断小数点后面的数。

- 各种基本数据类型进行混合运算，结果会是表达力最强的那种。如int和long运算，结果是long，整型和浮点型运算，结果是浮点型。特殊的一点是：只要类型比int小，（如char\byte\short）,那么在运算之前会自动地转换成int.

- 浮点类型的柯旭表示法。在数学中e代表自然对数（Math.E给出了double值），在java中e代表10的次幂。


#### 多重转型

```
public class Multicast {
  public static void main(String[] args) {
    System.out.println((int) (char) (byte) -1);
  }
}

```



---

内容来自《java解惑》 作者：布洛赫
