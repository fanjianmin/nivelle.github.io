---
layout: post
title:  "多线程高级特性"
date:   2015-10-06 00:06:05
categories: 多线程
tags: 多线程
excerpt: 多线程高级特性

---

* content
{:toc}


### 显式锁

ReentrantLock并不是一种替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。

与内置锁不同，Lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显式的。在Lock的实现中必须提供与内部锁相同的内存可见性语义，但在加锁语义、调度算法、属性保证以及性能特性等方面可以有所不同。

```
public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(lon timeout,TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
    
}

```
ReentantLock实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性。在获取ReentrantLock时，有着与进入同步代码块相同的内存语义，在释放ReentrantLock时，同样有着与退出同步代码块相同的内存语义。

与synchronized一样，ReentrantLock还提供了可重入的加锁语义。

内置锁必须必须在获取该锁的代码中释放，这就简化了编码工作，并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构的加锁规则。

Lock接口的标准使用形式：必须在finally块中释放锁。否则，如果在被保护的代码中抛出了异常，那么这个锁永远都无法释放。当使用加锁时，还必须考虑在try块中抛出异常的情况，如果可能使对象处于某种不一致的状态，那么就需要更多的try-catch或try-finall代码块。

```
 Lock locl = new ReentrantLock();
 ...
 lock.lock();
 try{
   //更新对象状态
   // 捕获异常，并在必要时恢复不变性条件
 }finally{
   lock.unlock();
 }

```

####  轮询锁与定时锁

可定时的与可轮询的锁获取模式是由tryLock方法实现的，与无条件的锁获取模式相比，它具有更完善的错误恢复机制。在内置锁中，死锁时一个严重的问题，恢复程序的唯一方法是重新启动程序，而防止死锁的唯一方法是在构造程序时避免出现不一致的锁顺序。可定时的与可轮询的锁的锁提供了另一种选择：避免死锁的发生。

如果不能获得所有需要的锁，那么可以使用可定时或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。

####  读写锁

ReadWriteLock接口中暴露了两个Lock对象，其中一个用于读操作，而另一个用于写操作。要读取由ReadWriteLock保护的数据，必须首先获获得读取锁，当需要修改ReadWriteLock保护的数据时，必须首先获得写入锁。尽管这两个锁看上去是相互独立的，但读取锁和写入锁只是读————写锁对象的不同视图。

```
public interface ReadWriteLock{
  Lock readLock();
  Lock writeLock();
}

```
在读——写锁实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。

#### 条件队列

它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。传统队列的元素是一个个数据，而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。

正如每个Java对象都可以作为一个锁，每个对象同样可以作为一个条件队列，并且Object中的wait、notify和notifyAll方法就构成了内部条件队列的API.对象的内置锁与其内部条件队列是相互关联的，要调用对象X中条件队列的任何一个方法，必须持有对象X上的锁。这是因为“等待由状态构成的条件”与“维护状态一致性”这两种机制必须被紧密地绑定在一起：只能对状态进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。

Object.wait会自动释放锁，并请求操作系统挂起当前线程，从而使得其他线程能够获得这个锁并修改对象的状态。当被挂起的线程醒来时，它将在返回之前重新获取锁。从直观上来理解，调用wait意味着“我要去休息了，但当发生特定的事情时唤醒我”，而调用通知方法就意味着“特定的事情发生了”。



#### 显式的Condition对象

