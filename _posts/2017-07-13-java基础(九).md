---
layout: post
title:  "java基础(九)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 类型信息

RTTI:在运行时，识别一个对象的类型。

运行时类型信息使得你可以在程序运行时发现和使用类型信息。 

#### Class对象

Java中，运行时类型信息是由Class对象来完成的，它包含了与类有关的信息。事实上，class对象就是用来创建类的所有常规对象的。java使用Class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。

类是程序的一部分，每个类都有一个Class对象。每当编写且编译了一个新类，就会产生一个Class对象(被保存在一个同名的.class文件中)为了生成这个类的对象，运行这个程序的JAVA虚拟机(JVM)将使用被称为“类加载器”的子系统。它包含一条类加载器链，但是只有一个原生类加载器，用来加载可信类，包括Java API类，它们通常是从本地磁盘加载的。

所有的类都是在第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员引用时，就会加载这个类。同时证明，构造器也是类的静态方法，即使在构造器之前没有使用static关键字。因此，使用new 操作符创建类的新对象也会被当做类的静态成员的引用。

---

java程序在它开始之前并非完全加载，其各部分是必需时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类目查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良java代码。

一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

---


```
package learn;

class Candy {
  static {
    System.out.println("Loading Candy");
  }
}

class Gum {
  static {
    System.out.println("loading Gum");
  }
}

class Cookie {
  static {
    System.out.println("loading Cookie");
  }
}

public class SweetShop {
  public static void main(String[] args) {
    System.out.println("inside main");
    new Candy();
    System.out.println("after create Candy");
    try {
      Class.forName("learn.Gum");
    } catch (ClassNotFoundException e) {
      System.out.println("cound't find Gum");
    }
    System.out.println("after class.forName(\"Gum\")");
    new Cookie();
    System.out.println("after creating Cookie");
  }
}

```
结论：
inside main

Loading Candy

after create Candy

loading Gum

after class.forName("Gum")

loading Cookie

after creating Cookie

---

Class.forName("Gum"),这个方法是Class类（所有Class对象都属于这个类）的一个static成员。Class对象就和其他对象一样，我们可以获取并操作它的引用（这也就是类加载器的工作）。forName（）是取得Class对象的引用的一种方法，返回的是一个Class对象的引用。如果类还没有被加载，那么就加载它。

```
package learn;

interface HasBatteries{}
interface Waterproof{}
interface Shoots{}

class Toy{
  public Toy() {
    
  }
  public Toy(int i){}
}
class FancyToy extends Toy implements HasBatteries,Waterproof,Shoots{
  public FancyToy() {
    super(1);
  }
}
public class ToyTest {
  static void printInfo(Class cc){
    System.out.println("Class name:"+cc.getName()+" is interface?"+cc.isInterface());//权限定类目
    System.out.println("Simple name:"+cc.getSimpleName());//不包含包名的类名
    System.out.println("Canonical name:"+cc.getCanonicalName());//全限定的类名
  }
  
  public static void main(String[] args){
    Class c =null;
    try {
      c=Class.forName("learn.FancyToy");
    } catch (ClassNotFoundException  e) {
      System.out.println("cant find facyToy");
      System.exit(1);
    }
    printInfo(c);
    for(Class face:c.getInterfaces()){
      printInfo(face);
    }
    Class up =c.getSuperclass();
    Object obj =null;
    try{
      obj =up.newInstance();
    }catch(InstantiationException e){
      System.out.println("cant instantiate");
      System.exit(1);
    }catch (IllegalAccessException e) {
      System.out.println("cant access");
      System.exit(1);
    }
    printInfo(obj.getClass());
  }
}


```
---

Class name:learn.FancyToy is interface?false

Simple name:FancyToy

Canonical name:learn.FancyToy

Class name:learn.HasBatteries is interface?true

Simple name:HasBatteries

Canonical name:learn.HasBatteries

Class name:learn.Waterproof is interface?true

Simple name:Waterproof

Canonical name:learn.Waterproof

Class name:learn.Shoots is interface?true

Simple name:Shoots

Canonical name:learn.Shoots

Class name:learn.Toy is interface?false

Simple name:Toy

Canonical name:learn.Toy

---

Class的newInstance()方法实现“虚拟机构造器”的一种途径，虚拟机构造器允许声明：我不知道确切类型，但是可也能创建自己。上面例子中，up仅仅是一个Class引用，在编译期不具备。当创建实例时，会得到Object引用，但是这个引用指向的是Toy对象。


#### 类字面常量

java还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。

就像下面这样：

```
FancyToy.class

```
这样做不仅更简单，而且更安全，因为它在编译时就会受到检查(因此不需要置于try块中)。并且根除了对forName()方法的调用，所以也更有效。

类字面常量不仅可以应用于普通的类，也可以应用于接口、数组以及基本数据类型。对于基本数据类型的包装器类，还有一个标准字段TYPE.TYPE字段是一个引用，指向对象的基本数据类型的Class对象。

```
boolean.class === Boolean.TYPE
char.class ==== Character.TYPE
byte.class=== Byte.TYPE
short.class===Short.TYPE
int.class === Integer.TYPE
long.class === Long.Type
float.class === Float.Type
double.class === Double.Type
void.class === Void.TYPE

建议使用“.class”的形式，以保持与普通类的一致性。

**当使用".class"来创建对Class对象的引用时，不会自动地初始化该Class对象。**为了使用类而坐的准备工作实际包含三个步骤：

- 加载：类加载器执行。该步骤将查找字节码(通常在classpath所指定的路径中查找，但这并非必须的)，并从这些字节码中创建一个Class对象。

- 链接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。

- 初始化：如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。

初始化被延迟到了静态方法（构造器隐式地是静态的）或者非常数静态域进行首次引用时才执行：

```
package learn;

import java.util.Random;


class Initable {
  static final int staticFinal = 47;
  static final int staticFinal2 = ClassInitialization.rand.nextInt(1000);

  static {
    System.out.println("initializing initable");
  }
}

class Initable2 {
  static int staticNonFinal = 147;

  static {
    System.out.println("Initiaizaing initable2");
  }
}

class Initable3 {
  static int staticNonFinal = 74;

  static {
    System.out.println("Initiaizaing initable3");
  }
}

public class ClassInitialization {
  public static Random rand = new Random(47);

  public static void main(String[] args) throws ClassNotFoundException {
    Class initable = Initable.class;
    System.out.println("after creating Initable ref");
    System.out.println(Initable.staticFinal);
    System.out.println(Initable.staticFinal2);
    System.out.println(Initable2.staticNonFinal);
    Class initable3 = Class.forName("learn.Initable3");
    System.out.println("after creating Initable3 ref");
    System.out.println(Initable3.staticNonFinal);
  }

}

```
结果：
after creating Initable ref

47

initializing initable

258

Initiaizaing initable2

147要进行链接()

Initiaizaing initable3

after creating Initable3 ref

74

---

初始化有效地实现了尽可能的“惰性”。从对initable引用的创建中可以看到，仅使用.class语法来获得对类的引用不会引发初始化。但是，为了产生Class引用，Class.forName()立即就进行了初始化，就像在对initable3引用的创建中所看到的。

如果一个static final值时“编译期常量”，就像Initable.staticFinal那样，那么这个值不需要对Initable类进行初始化就可以被读取。但是，如果只是将一个域设置为static和final的，还不足以确保这种行为。

如果一个static域不是final的，那么在对它访问时，总是要求在它被读取之前，要先进行链接(为这个域分配存储空间)和初始化(初始化该存储空间)，就像在对Initable2.staticNonFinal的访问中所看到的那样。


#### 泛化的Class引用

