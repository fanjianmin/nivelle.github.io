---
layout: post
title:  "java基础(九)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 类型信息

RTTI:在运行时，识别一个对象的类型。

运行时类型信息使得你可以在程序运行时发现和使用类型信息。 

#### Class对象

Java中，运行时类型信息是由Class对象来完成的，它包含了与类有关的信息。事实上，class对象就是用来创建类的所有常规对象的。java使用Class对象来执行其RTTI，即使你正在执行的是类似转型这样的操作。

类是程序的一部分，每个类都有一个Class对象。每当编写且编译了一个新类，就会产生一个Class对象(被保存在一个同名的.class文件中)为了生成这个类的对象，运行这个程序的JAVA虚拟机(JVM)将使用被称为“类加载器”的子系统。它包含一条类加载器链，但是只有一个原生类加载器，用来加载可信类，包括Java API类，它们通常是从本地磁盘加载的。

所有的类都是在第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员引用时，就会加载这个类。同时证明，构造器也是类的静态方法，即使在构造器之前没有使用static关键字。因此，使用new 操作符创建类的新对象也会被当做类的静态成员的引用。

---

java程序在它开始之前并非完全加载，其各部分是必需时才加载的。类加载器首先检查这个类的Class对象是否已经加载。如果尚未加载，默认的类加载器就会根据类目查找.class文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良java代码。

一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。

---


```
package learn;

class Candy {
  static {
    System.out.println("Loading Candy");
  }
}

class Gum {
  static {
    System.out.println("loading Gum");
  }
}

class Cookie {
  static {
    System.out.println("loading Cookie");
  }
}

public class SweetShop {
  public static void main(String[] args) {
    System.out.println("inside main");
    new Candy();
    System.out.println("after create Candy");
    try {
      Class.forName("learn.Gum");
    } catch (ClassNotFoundException e) {
      System.out.println("cound't find Gum");
    }
    System.out.println("after class.forName(\"Gum\")");
    new Cookie();
    System.out.println("after creating Cookie");
  }
}

```
结论：
inside main

Loading Candy

after create Candy

loading Gum

after class.forName("Gum")

loading Cookie

after creating Cookie

---

Class.forName("Gum"),这个方法是Class类（所有Class对象都属于这个类）的一个static成员。Class对象就和其他对象一样，我们可以获取并操作它的引用（这也就是类加载器的工作）。forName（）是取得Class对象的引用的一种方法，返回的是一个Class对象的引用。如果类还没有被加载，那么就加载它。

```
package learn;

interface HasBatteries{}
interface Waterproof{}
interface Shoots{}

class Toy{
  public Toy() {
    
  }
  public Toy(int i){}
}
class FancyToy extends Toy implements HasBatteries,Waterproof,Shoots{
  public FancyToy() {
    super(1);
  }
}
public class ToyTest {
  static void printInfo(Class cc){
    System.out.println("Class name:"+cc.getName()+" is interface?"+cc.isInterface());//权限定类目
    System.out.println("Simple name:"+cc.getSimpleName());//不包含包名的类名
    System.out.println("Canonical name:"+cc.getCanonicalName());//全限定的类名
  }
  
  public static void main(String[] args){
    Class c =null;
    try {
      c=Class.forName("learn.FancyToy");
    } catch (ClassNotFoundException  e) {
      System.out.println("cant find facyToy");
      System.exit(1);
    }
    printInfo(c);
    for(Class face:c.getInterfaces()){
      printInfo(face);
    }
    Class up =c.getSuperclass();
    Object obj =null;
    try{
      obj =up.newInstance();
    }catch(InstantiationException e){
      System.out.println("cant instantiate");
      System.exit(1);
    }catch (IllegalAccessException e) {
      System.out.println("cant access");
      System.exit(1);
    }
    printInfo(obj.getClass());
  }
}


```
---

Class name:learn.FancyToy is interface?false

Simple name:FancyToy

Canonical name:learn.FancyToy

Class name:learn.HasBatteries is interface?true

Simple name:HasBatteries

Canonical name:learn.HasBatteries

Class name:learn.Waterproof is interface?true

Simple name:Waterproof

Canonical name:learn.Waterproof

Class name:learn.Shoots is interface?true

Simple name:Shoots

Canonical name:learn.Shoots

Class name:learn.Toy is interface?false

Simple name:Toy

Canonical name:learn.Toy

---

Class的newInstance()方法实现“虚拟机构造器”的一种途径，虚拟机构造器允许声明：我不知道确切类型，但是可也能创建自己。上面例子中，up仅仅是一个Class引用，在编译期不具备。当创建实例时，会得到Object引用，但是这个引用指向的是Toy对象。
