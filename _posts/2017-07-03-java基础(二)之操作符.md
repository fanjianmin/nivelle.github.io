---
layout: post
title:  "java基础(二)之操作符"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---


* content
{:toc}

### 使用java操作符

操作数接收一个或多个参数，并生成一个新值。参数的形式与普通的方法调用不同，但效果是相同的。

几乎所有的操作符都只能操作“基本类型”。例外的操作符是“=”、“==”和“!=”,这些操作符能操作所有对象。除此之外,String 类支持“+”和“+=”。

### 赋值

赋值使用操作符“=”。它的意思“取右边的值(即右值)，把它赋值给左边(即左值)”.

对基本数据类型的赋值很加单。基本类型存储了实际的数值，而并非指向一个对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另一个地方。例如,对基本数据类型使用a=b,那么b的内容就复制给a。若接着有修改了a,而b根本不会受到这种修改的影响。

但是在位对象“赋值”的时候，对一个对象进行操作时，我们真正操作的是对对象的引用。所以倘若“将一个对象赋值给另一个对象”，实际是将“引用”从一个地方复制到另一个地方。这意味着若对对象使用c=d，那么c和d都指向原本只有d指向的那个对象。

### 算术操作符

java基本操作符与其他大多数程序设计语言是相同的。其中包括加号(+)、减号(-)、除号(/)、乘号(*)以及取模操作符(%,它从整除法中产生余数)。整数除法会直接去掉结果小数位，而不是四舍五入地园整结果。

```
Random类对象，如果在创建过程中没有传递任何参数，那么java就会将当前的时间作为随机数生成器的种子，并由此在程序每一次执行时都产生不同的输出。

传递给nextInt()的参数设置了产生的随机数上限，而其下限为0，但是这个下限并不是我们想要的，因为它会产生除0的可能性。同时也不会产生上限值得随机数。

```

### 自动递增和递减

对于前缀形式，我们在执行运算完运算后才得到值，但对于后缀形式，则是在运算之前就得到值。他们是除那些涉及赋值的操作符以外，唯一具有“副作用”的操作符。

### 关系操作符

关系操作符生成的是一个boolean(布尔)结果，他们计算的是操作数的值之间的关系。如果关系是真实的，关系表达式会生成true;如果关系不真实，则生成false.关系操作符包括小于(<)、大于(>)、小于等于(<=)、大于等于(>=)、等于(==)以及不等于(!=).

```
Integer n1=new Integer(47);
Integer n2 = new Integer(47);
System.out.println(n1==n2);
System.out.println(n1!=n2);

```
尽管两个对象内容相同，然而对象的引用却是不同的，而==和!=比较的就是对象的引用。要比较实际内容，则应该使用所有对象都适用的equals()方法。但这个方法不适用与“基本类型”，基本类型直接使用==和!=即可。

```
class Value{
    int i;
}

public class EqualsMethod{
    public static main(String []args){
        Value v1= new Value();
        Value v2 =new Value();
        v1.i=v2.i=100;
        System.out.pritln(v1.equals(v2));
    }
}

结果：false;
```
对于自己定义的对象，**equals()默认的行为是比较引用**，所以需要自己定义比较的对象的比较实质内容是什么，需要我们自己去重写这个equals()方法。

### 逻辑操作符

逻辑操作符“与”(&&)、“或”(||)、“非”(!)能根据参数的逻辑关系，生成一个布尔值(true或fals).与、或、非操作只可应用于布尔值，不可将一个非布尔值当做布尔值在逻辑表达式中使用。

### 直接常量

直接常量后面的后缀字符标志它的类型。若为大写的L,代表long;大写的字母F,代表float;大写字母D,则代表double。

十六进制适用于所有整数数据类型，以前缀0X,后面跟0-9或大小写字母a-f来表示。

八进制数由前缀0以及后续的0~7的数字来表示。

如果试图将一个变量初始化成超出自身表示范围的值，编译器都会报告一条错误信息。

byte-8位，short-16位,char-16位，如果赋值超出他们能表示的数值，编译器会自动转换成int型，并告诉我们需要窄化转型。

### 指数计数法

在java中，e代表“10的次幂”。1.39e-43f这样的表达式代表的意思是：1.39*10-43.

如果编译器能够正确地识别类型，就不必在数值后面附加字符。例如语句

```
long n3 =200;
```
编译器通常会将指数作为双精度(double)处理，所以假如没有这个尾随的f，就会收到一条出错提示，告诉我们必须使用类型转换将double转换成float。


### 按位操作符

按位操作符用来操作整数基本数据类型中的单个“比特”(bit),即二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。

如果两个输入位都是1，则按位与操作符(&)生成一个输出位1；否则生成一个输出位0；
如果两个输入位里只有一个是1，则按位或(|)生成一个输出位1，只有在两个输入位都是0的情况下，才会生成一个输出位0.
如果输入位的某一个是1，但不全都是1，那么按位“异或”操作(^)生成一个输出位1.
按位“非”(~),也称为取反操作符，它属于一元操作符，只对一个操作数进行操作。按位非生成与输入位相反的值---如输入0，则输出1；若输入1，则输出0；

### 移位操作符

移位操作符操作的运算对象也是二进制的“位”。移位操作符只可用来处理整数类型。左移位操作符(<<)能按照操作符右侧指定的位数将操作符左边操作数向左移动(在低位补0).

"有符号"右移(>>)则按照操作符右侧指定的位数将操作符左边的操作数向右移动。“有符号”右移位操作符使用“符号扩展”：若符号为正，则在高位插入0；若符号为负，则在高位插入1.

java中增加了一种无符号右意味操作符(>>>),它使用“零扩展”：无论正负，都在高位插入0。

如果对char、byte或者short类型的数值进行移位处理，那么在移位进行之前，他们会被转换为Int类型，并且得到的结果也是一个int类型，并且得到的结果也是一个int类型的值。

如果对byte或short值进行这样的移位运算，得到可能不是正确的结果。它们会先被转换成int类型，再进行右移操作，然后被截断，赋值给原来的类型，在这种情况下可能得到-1的结果。

### 三元操作符

boolean -exp ? value0:value1
如果boolean-exp(布尔表达式)的结果为ture，就计算value0,而且这个计算结果也就是操作符最终产生的值。如果boolean-exp的结果为false，就算value1,同样它的结果就成为操作符的最终产生的值。

### 字符串操作符 + 和 +=

字符串操作符有一些有趣的行为：如果表达式以一个字符串起头，那么后续所有操作数必须是字符串型。

**窄化转换：** 将能容纳更多信息的数据类型转换为无法容纳那么多信息的类型，可能面临信息丢失的危险。此时编译器会要求进行强制类型转换。

**拓展转换：**不必进行显示的类型转换，因为新的类型肯定能容纳原来的类型信息，不会造成任何数据丢失。

java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，后者不允许任何类型的转换处理。

#### 截尾

将float或者double转型为整型的时候，总是对该数字执行截尾。如果想要的到舍入的结果，就需要使用java.lang.Math中的round()方法。

#### 提升

如果是对基本数据类型执行算术运算或者按位运算，只要比int小(char,byte,short),在运算之前，这些值都会自动转成int。这样一来，最终的结果就是int类型，如果想把结果赋值给较小的类型，就必须使用类型转换。（可能存在信息丢失）。通常，表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float与一个double相乘，结果就是double;如果将一个int和一个long值相加，结果为long。

### static 关键字

通常对象在使用new来创建时，数据空间被分配，其方法才供外界使用。有两种情形无法用new操作来满足：

- 只想为某个特定的域分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。

- 希望某个方法不与包含它的类的任何对象关联在一起，即使没有创建对象对象，也能调用这个方法。

static关键字可以满足这两方面的要求：当申明一个事务是static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。

使用类名是引用static变量都首选方式，这不仅是因为它强调了变量的static结构，而且在某些情况下它还未编译器优化提供了更好的机会。

static方法可以创建或使用与其类型相同的被命名对象，一次static方法常常拿来做“牧羊人”角色，负责看护与其隶属同一类型的实例群。

static方法就是没有this的方法。在static方法的内部无法引用非静态方法，反过来到是可以。
