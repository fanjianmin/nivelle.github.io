---
layout: post
title:  "I/O多路复用"
date:   2017-09-22 01:06:05
categories: 技术
tags: I/O多路复用
excerpt: I/O多路复用
---


* content
{:toc}


### 常见IO模型

- 同步阻塞:传统的IO模型

- 同步非阻塞:默认创建的socket都是阻塞的,非阻塞IO要求socket被设置为NONBLOCK.(非java的NIO库)

- IO多路复用:经典的Reactoe设计模式,有时也称为异步阻塞IO,java中的selector和linux中的epoll都是这种模式

- 异步IO:经典的Proactor设计模式,也称为异步非阻塞IO


#### 同步和异步:

描述的是用户线程与内核的交互方式,同步指的是用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行;异步指的是用户线程发起IO请求后任继续执行,当内核IO操作完成后会通知用户线程,或者调用用户线程注册的回调函数.


#### 阻塞和非阻塞

描述的是用户线程调用内核IO操作的方式:阻塞是指IO操作需要彻底完成胡才安徽到用户空间;而非阻塞是指IO操作被调用后立即返回给用户一个状态值,无需等到IO操作彻底完成.


### 同步阻塞IO

同步阻塞IOs是最简单的IO模型,用户线程在内核进行IO操作时会被阻塞.

![image](http://images.cnitblog.com/blog/405877/201411/142330286789443.png)

如图:用户线程通过系统调用read发起IO读操作,由于用户空间转到内核空间.内核等到数据包到达后,然后将接收的数据拷贝到用户空间.

```
{
    read(socket,buffer);
    
    process(buffer)
}


```
用户需要等待read将socket中的数据读取到buffer之后,才继续处理接收到的数据.整个IO请求过程过程中,用户线程是被阻塞的,这导致用户在发起IO请求时,不能做任何事情,对CPU的资源利用率不够.

### 同步非阻塞IO

同步非阻塞IO是在同步阻塞IO的基础上，将socket设置为NONBLOCK。这样做用户线程可以在发起IO请求后可以立即返回。

![image](http://images.cnitblog.com/blog/405877/201411/142332004602984.png)

由于socket是非阻塞方式,因此用户线程发起IO请求时立即返回,但并未读取到任何数据,用户给线程需要不断地发起IO请求,直到数据到达后,才真正读取到数据,继续执行.

```
{
    while(read(socket,buffer)!=success)
    
    process(buffer);
}

```
即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。

### IO多路复用

IO多路复用是建立在内核提供的多路分离函数select基础之上的,使用select函数可以避免同步非阻塞IO模型中轮询等待的问题.

![image](http://images.cnitblog.com/blog/405877/201411/142332187256396.png)

### 异步IO

---

[转载至](http://blog.csdn.net/baixiaoshi/article/details/48708347)
