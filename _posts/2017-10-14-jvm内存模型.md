---
layout: post
title:  "jvm内存模型."
date:   2017-10-11 00:06:05
categories: jvm
tags: jvm
excerpt: jvm
author: nivelle
---

* content
{:toc}


### JVM内存管理

#### 物理内存和虚拟内存

物理内存就是我们常说的RAM(随机存储器).还有一个存储单元叫寄存器,它用于存储计算单元执行指令(浮点,整数等运算时)的中间结果.


我们运行程序,要向操作系统先申请内存地址.通常操作系统管理内存的申请空间是按照进程来管理的,每个进程拥有一段独立的地址空间,每个进程之间不会相互重合,操作系统也会保证每个进程只能访问自己的内存空间.


虚拟内存:虚拟内存使得多个进程在同时可以共享物理内存,这里的共享空间是空间上共享,在逻辑上任然不能互相访问.虚拟地址不但可以让进程共享物理内存,提高内存利用率,而且还能扩展内存的地址空间.虚拟地址可以被映射到一段物理内存,文件或者其他可以寻址的存储上.


一个进程在不活动的情况下,操作系统将这个物理内存中的数据移动一个磁盘文件中,而真正高效的物理内存留给赈灾活动的程序使用.重新唤醒一个很长时间没有使用的程序时,磁盘会吱吱作响,并且会有一个短暂的停顿得到印证,这时操作系统又会报磁盘上的数据重新交互到物理内存中.


#### jvm板块

![image](http://7xpuj1.com1.z0.glb.clouddn.com/jvm%E5%86%85%E5%AD%98%E6%9D%BF%E5%9D%97.png) 

Heap就是我们经常说的"堆",它主要包括两大板块:Yong和Old,两个板块在分配内存的方法和Heap类似,但是回收的方式区别很大.通常来说,Yong空间会小很多,具体比例是多少要看应用场景和配置.Yong(年轻代)和Old(老年代)的划分.

Heap总大小使用-Xms来设置它的初始值,使用-Xmx来设置它的上限,在服务器端我们通常将这两个值设置为一样大.

一般Yong空间都用-Xmn来设置,Yong空间被封为两个部分,3个板块,即"一个Eden区 + 2个Survivor区"

- Eden:我们使用new()或者newInstance()等方法创建的对象,默认都是先将对象空间放置到Eden区域的(除非这个对象太大了Eden区域放不下,或设置了一个对象阈值:-XX:PretenureSizeThreadhold,这样对象就会直接进入Old区域)
- 2个Survivor区域通常简称为S0,S1,理论上可以认为S0和S1是一样大的,当设置某些动态参数设置后,这两个区域的大小可能会发生一些变化.

##### 工作原理

- 在不断创建对象过程中,Eden区域会满,满的时候就会开始做Yong GC(也称为Minor GC),而Yong 空间的的第一次GC就是找出"Eden区域活着的对象",将这些活着的对象向S0或S1其中一个区域存放.

假设第一次选择了S0,它会逐步将活着的对象拷贝到S0区域,但是如果S0空间放满了,剩下活着的对象只能放在Old区域了,接下来的动作是直接将Eden区域清空,此时S1区域是空的

- 第二次Eden区域满的时候,就将"Eden中活着的对象+S0活着的对象"迁移到S1,迁移方式也是一样的(同样,如果S1放不下,对象就会放到Old区域),只是这一次对象来源增加了S0区域的对象,最后被清空的区域是Eden区域和S0区域.
- 第三次,第四次操作以此类推,S0和S1始终有个一是空的.

![image](http://7xpuj1.com1.z0.glb.clouddn.com/MinorGC.png)
