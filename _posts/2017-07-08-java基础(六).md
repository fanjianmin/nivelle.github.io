---
layout: post
title:  "java基础(六)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 多态

多态通过分离做什么和怎么做，从另一个角度角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建可拓展的程序———既无论在项目最初创建还是在需要添加新功能时都可以“生长”的程序。

多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一个基类导出而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。

#### 方法调用绑定

将一个方法调用同一个方法主体关联起来被称为绑定。若在程序执行前进行绑定(如果有的话，由编译器和连接程序实现)，前期绑定，只有一个基类引用，它无法知道调用那个方法才对。

后期绑定：动态绑定或运行绑定，在运行时能判断对象的类型，从而调用恰当的方法，也就是说，编译器一直不知道 对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。后期绑定机制随着编程语言的不同而有所不同，不管怎样必须在对象中安置某种“类型信息”。

#### 产生正确的行为

java中所有的方法都是通过动态绑定实现多态，所以我们可以编写只与基类打交道的程序代码了，并且这些代码对所有的导出类都可以正确运行。

多态使得我们所做的代码修改，不会对程序中其他不应该受到影响的部分产生破坏。换句话说：多态让“将改变的事物与未改变的事物分离开来”。

#### 缺陷一：“覆盖”私有方法

```
public class PrivateOverride {
  private void f() {
    System.out.println("private f()");
  }

  public static void main(String[] args) {
    PrivateOverride po = new Derived();
    po.f();
  }
}

class Derived extends PrivateOverride {
  public void f() {
    System.out.println("public f()");
  }
}


```

结果：private f()

由于private方法被自动认为是final方法，而且对导出类屏蔽的。因此，在这种情况下，Drivied类中的f()方法就是一个全新的方法;既然基类中的f()方法在子类Drived中不可见，因此甚至也不能重载。

结论就是：只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类中的private方法，最好采用不同的名字。

#### 缺陷二：域与静态方法

只有普通的方法调用可以是多态的，如果某个方法是静态的，它的行为就不具有多态性。静态方法是与类，而并非与单个的对象相关联的。

### 构造器和多态

构造器不具有多态性(它们实际上是static方法，只不过该static声明式隐式的)，但还是非常非常有必要理解构造器怎样通过多态在复杂的层次结构中运作。

#### 构造器的调用顺序

基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上连接，以是每个基类的构造器都能得到调用。

导出类只能访问自己的成员，不能访问基类中的成员(基类成员通常是private类型)，只有基类的构造器才具有恰当的知识和权限来对自己的元素进行初始化。

---

构造器调用要遵循下面的顺序：

- 调用基类构造器。这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类。
- 按照声明顺序调用成员的初始化方法。
- 调用导出类构造器的主体。

#### 构造器内部的多态方法的行为





