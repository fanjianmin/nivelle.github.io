---
layout: post
title:  "多线程学习(二)"
date:   2017-05-27 00:06:05
categories: 技术
tags: 多线程
excerpt: 多线程深入学习
author: nivelle
---

* content
{:toc}

#### 对象的组合

#####  设计线程安全的类

设计线程安全类过程中，需要包含下面三个基本要素

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

** **

如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。

如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。

#####  实例封闭

封装简化了线程安全类的实现过程，它提供了一种实例封闭机制，通常也简称为“封闭”。当一个被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。

```
将数据封装在对象内部，可以将数据的访问现在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

```

---
#### 基础构建模块

##### 同步容器类

- 包括Vector和Hashtable，这些同步容器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个共有方法进行同步，使得每次只有一个线程能访问容器的状态。
- 同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。复合操作包括：地带、跳转、条件运算
- 由于同步容器类要遵守同步策略，即支持客户端加锁，因此可能会创建一些新的操作，只要我们知道应该使用哪一个锁，那么这些操作就与容器的其他操作一样都是原子操作。同步容器类通过其自身的锁来保护它的每个方法。通过获得容器类的锁，我们可以使getLast和deleteLast成为原子操作.如下：

```
public static Object getLast(Vector list){
    synchronized(list){
        int lastindex = list.size()-1;
        return list.get(lastindex);
    }
}

public static void deletelast(Vector list){
    synchronized(list){
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}
```

######  隐藏迭代器

编译器将字符串的链接操作转换为调用StringBuilder.append(Object),而这个方法又会调用容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示。

```
public class HiddenIterator{
    @GuardedBy("this")
    private final Set<Integer>set = new HashSet<Integer>();
    
    public synchronized void add(Integer i){set.add(i);}
    
    public synchronized vod remove(Integer i){set.remove(i);}
    
    public void addTenThings(){
        Random r = new Random();
        for(int i=0;i<10;i++)
           add(r.nextInt());
        System.out.println("DEBUG:added ten elementsto"+set);
    }
}

```

容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或者键值时，就会出现这种情况。同样，containsAll、removeALL和retainALL等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都肯能抛出ConcurrentModificationException。


#####  并发容器

同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。

Java 5.0中增加了ConcurrentHashMap，用来代替同步且基于散列的Map,以及CopyOnWriteArrayList，用于在遍历操作为主要操作的情况下代替同步的List。

- ######  ConcurrentHashMap: 同步容器类在执行每个操作期间都持有一个锁。并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁。这种机制中，任意数量的读取线程可以并发地访问Map,执行读取操作的线程和执行写入操作的线程可以并发地访问Map,并且一定数量的写入线程可以并发地修改Map。这样在并发访问环境下实现更高吞吐量，而在单线程环境中只损失非常小的性能。

- ######  在ConcurrentHashMap中没有实现对Map加锁以提供单独访问。在Hashtable和synchronized-Map，获取Map的锁能防止其他线程访问这个Map.
- ######  CopyOnWriteArrayList 
