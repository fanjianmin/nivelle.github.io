---
layout: post
title:  "多线程学习(二)"
date:   2017-05-27 00:06:05
categories: 技术
tags: 多线程
excerpt: 多线程深入学习
author: nivelle
---

* content
{:toc}

#### 对象的组合

#####  设计线程安全的类

设计线程安全类过程中，需要包含下面三个基本要素

- 找出构成对象状态的所有变量
- 找出约束状态变量的不变性条件
- 建立对象状态的并发访问管理策略

** **

如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。

如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。

#####  实例封闭

封装简化了线程安全类的实现过程，它提供了一种实例封闭机制，通常也简称为“封闭”。当一个被封装到另一个对象中时，能够访问被封装对象的所有代码路径都是已知的。

```
将数据封装在对象内部，可以将数据的访问现在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

```

---
#### 基础构建模块

##### 同步容器类

包括Vector和Hashtable，这些同步容器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将他们的状态封装起来，并对每个共有方法进行同步，使得每次只有一个线程能访问容器的状态。

##### 隐藏迭代器

编译器将字符串的链接操作转换为调用StringBuilder.append(Object),而这个方法又会调用容器的toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示。

```
public class HiddenIterator{
    @GuardedBy("this")
    private final Set<Integer>set = new HashSet<Integer>();
    
    public synchronized void add(Integer i){set.add(i);}
    
    public synchronized vod remove(Integer i){set.remove(i);}
    
    public void addTenThings(){
        Random r = new Random();
        for(int i=0;i<10;i++)
           add(r.nextInt());
        System.out.println("DEBUG:added ten elementsto"+set);
    }
}

```

容器的hashCode和equals等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或者键值时，就会出现这种情况。同样，containsAll、removeALL和retainALL等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都肯能抛出ConcurrentModificationException。


#####  并发容器













