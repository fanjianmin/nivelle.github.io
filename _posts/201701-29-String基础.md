---
layout: post
title:  "String"
date:   2017-10-29 00:06:05
categories: java
tags: String
excerpt: String基础
author: nivelle
---

* content
{:toc}

### String

```

 public static void main(String args[]){
       String a = "a"+"b"+1;
        String b = "ab1";
        System.out.println(a==b);
    }

```

 **结果是:true.**
 
 #### 关于 "=="
 
 == 用于匹配内存单元上的内容,其实就是一个数字,计算机内部也只有数字,java中当"=="匹配的时候,其实就是对比两个内存单元的内容是否一样.
 
 如果是原始类型byte,boolean,short,char,int,long,float,double就是直接比较他们的值.
 
 如果是引用,比较的就是引用的值,"引用的值"可以被认为是对象的逻辑地址.如果两个引用发生"=="操作,就是比较相应的两个对象的地址值是否一样.如果两个引用所保存的是同一个对象,则返回true,否则返回false.
 
 
 #### 关于"equals()"
 
 在Object类中被定义,它的定义中就是使用"=="方式来匹配的.也就是说,如果不去重写equals()方法,那么默认的equals()操作就是比较对象的地址.
 
 
 ##### hashCode()
 
 hashCode()方法提供了对象的hashCode值,它与equals()一样在Object类中提供,不过它是一个native(本地)方法,它的返回值默认与System.identityHashCode(object)一致.在通常情况下,这个值是对象头部的一部分二进制位组成的数字,这个数字具有一定的标识对象的意义存在,但不等价于地址.
 
 hashCode的作用:它为了产生一个可以标识对象的数字,不论如何复杂的一个对象都可以用一个数字来标识.目的是为了将对象应用在算法中,如果不这样,许多算法还得自己去组装数字,因为算法的基础是建立在数字基础之上的.
 
 hashCode只能说是标识对象,因此在Hash算法中可以将对象相对离散开,这样就可以在查找数据的时候根据这个key快速地缩小数据范围.但不能说hashCode值一定是唯一的,所以在hash算法中定位到具体链表后,需要进一步循环链表,然后通过equals()来对比Key的值是否是一样的.换句话说:一个是为了算法快速定位数据而存在的,一个是为了对比真实值而存在的.
 
 ```
 JDK1.7中,Hash相关的集合类对使用String作为Key的情况,不再使用hashCode方式,而是一个hash32属性,其余类型保持不变.
 
 
 ```
 
 #### 编译时优化方案
 
 当编译器编译代码
 
 ```
 String a = "a" +"b" +1;时,会将其编译为String = "ab1";
 
 ```
 
编译器优化一定是在编译阶段能确定优化后不会影响整体功能,类似于final引用,这个引用只能被赋值一次,但它无法确定赋值的内容是什么.只有在编译阶段能确定这个final引用的赋值内容,编译器才可能进行编译时优化,而编译期间能确定的内容来自于常量池中,例如:int,long,String等常量,也就是不包含new String(),new Interger()这样的操作,因为这个是运行是决定的,也不包含方法返回值.因为运行时它可能返回不同的值.

String.equals()的代码逻辑大致如下:

- 判定传入的对象和当前对象是否为同一个对象,如果是就直接返回true
- 判定传入对象的类型是否为String,若不是则返回false
- 判定传入的String 与当前String对象长度是否一致,若不一致就返回false
- 循环对比两个字符串的char[]数组,逐个对比字符串是否一致,若存在不一致的情况,则直接返回false
- 循环结束没有找到不匹配的,返回true


#### StringBuilder.append()与String "+"的PK

String 通过"+"拼接的时候,如果拼接的对象是常量,则会在被编译器编译时合并优化,这个合并操作是在编译阶段完成的,不需要运行时再分配空间,自然效率最高.


不是String的"+"操作本身慢,而是循环中大量的内存使用使得它的内存开销变大,导致了系统频繁的GC(在很多时候时候程序慢都是因为GC多造成的),而且是更多的FULL GC,效率才会急剧下降.


JVM中,提倡的重点是让这个"线程内所使用的内存"尽快结束,一遍让JVM认为它是垃圾,在Yong空间就尽快释放掉,尽量不要让它进入Old区域.一个很重要的因素是代码释放跑的够快,其次是分配的空间足够小.
