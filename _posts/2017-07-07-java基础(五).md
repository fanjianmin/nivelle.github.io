---
layout: post
title:  "java基础(五)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 复用类

复用代码

- 只需要在新的类中产生现有类的对象，由于新的类是由现有类的对象组成，所以这种方法称为组合。
- 它按照现有类的类型来创建新类，无需改变现有类的形式，采用现有类的形式并在其中添加新代码，也即继承。

#### 组合语法

每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String而你却只有一个对象时，该方法便会被调用。

编译器并不是简单地为每一个引用都创建默认对象，这一点很有意义，初始化这些引用，可以在以下位置进行：

- 在定义对象的地方。这意味着它们总是能够在构造器被调用之前被初始化。
- 在类的构造器中
- 就在正要使用这些对象之前，惰性初始化。
- 使用实例初始化。

#### 继承语法

当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从java的标准根类Object进行继承。在继承过程中，需要首先声明“新类与旧类相似”这种申明是通过在类的主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。

当这么做时，会自动得到基类中所有的域和方法。

方法必须是Public，默认是包访问权限。

在java中super表示超类的以，当前类就是从这个超类继承来的。为此，表达式super.方法()将调用基类版本的方法。

并不一定要使用基类的方法，也可以在导出类中添加新方法，其添加方式与在新类中添加任意方法一样，即对其加以定义即可。

#### 初始化基类

当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。 

java会自动在导出类的构造器中插入对基类构造器的调用。

```
public class Cartoon extends Drawing {
  public Cartoon() {
    System.out.println("cartoon constructor");
  }

  public static void main(String[] args) {
    Cartoon x = new Cartoon();
  }
}
class Art {
  Art() {
    System.out.println("art constructor");
  }
}

class Drawing extends Art {
  public Drawing() {
    System.out.println("Drawing constructor");
  }
}
```
结果：art constructor，Drawing constructor，cartoon constructor

构建过程是从基类“向外”扩散的，所以基类在导出类构造前可以访问它之前，就已经完成了初始化。

#### 带参数的构造器

如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须使用关键字super显示地编写调用基类构造器的语句，并且配以适当的参数列表。

```
class Game{
  public Game(int i) {
    System.out.println("Game constructor");
  }
}

class BoardGame extends Game{
  public BoardGame(int i) {
    super(i);
    System.out.println("board game constructor");
  }
}
public class Chess extends BoardGame{
   public Chess() {
     super(11);
     System.out.println("chess constructor");
  }
   public static void main(String args[]){
     Chess x = new Chess();
   }
}

```

#### 代理

java并没有提供对它的直接支持，这是继承与组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中，但与此同时我们在新类中暴露了该成员对象的所有方法。使用代理时可以拥有更多的控制能力，我们可以选择只提供在成员对象中的方法的某个子集。

### 确保正确清理

因为并不知道垃圾回收器何时将会被调用，或者它是否将被调用。因此，如果想要某个类清理一些东西，就必须显示地编写方法处理，并确保客户端程序员知晓他们必须要调用这一方法。

将清理动作置于finally子句中，防止异常出现。垃圾回收器是不可靠的，如果需要清理，最好是编写自己的清理方法，但不要使用finalize();

#### 名称屏蔽

如果java的基类拥有某个已经被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本。

```
class Homer {
  char dod(char c) {
    System.out.println("doh(char)");
    return 'd';
  }

  float dod(float c) {
    System.out.println("doh(folat)");
    return 1.0f;
  }
}
class Milhouse{};

class Bart extends Homer{
  void doh(Milhouse m){
    System.out.println("doh(Milhouse)");
  }
}

public class Hide {
  public static void main(String[] args) {
    Bart b =new Bart();
    b.dod(1);
    b.dod('x');
    b.dod(1.0f);
    b.doh(new Milhouse());
  }
}

```
虽然在Bart引入了一个新的重载方法，但是在Bart中Homer的所有重载方法都是可用的。

@Override 注解要求必须要覆写基类的一个具有相同名称和参数的方法，防止不小心重载了该方法，而不知道。

#### protected  关键字

理想世界中，仅靠关键字private就足够了。但在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但任然允许导出类成员访问它们。

就类用户而言，这是private的，但对于任何继承与此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。

#### 向上转型

