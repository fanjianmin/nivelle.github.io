---
layout: post
title:  "多线程学习"
date:   2017-05-09 00:06:05
categories: 技术
tags: 多线程
excerpt: 多线程深入学习
author: nivelle
---

* content
{:toc}

##  核心概念

### 线程的安全性

##### 线程安全：核心在于对状态访问进行管理，特别是对共享的和可变的状态的访问，一个对象是否需要是线程安全的，取决于它是否被多个线程访问，指的是在程序中访问对象的方式，而不是对象要实现的功能。当多个线程访问某个类时，这个类始终表现出真确的行为，那么就称这个类是线程安全的。

```
如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
 - 不在线程之间共享该状态变量
 - 将状态变量修改为不可变的变量
 - 在访问状态变量时使用同步
```
##### 线程安全的类：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

##### 对象的状态： 指的是存储在状态变量(例如实例或静态域)中的数据。对象的状态可能包括其他依赖对象的域。

```
无状态对象一定是线程安全的。

```
##### 竞态条件： 最常见的竞态条件类型就是“先检查后执行”。首先观察到某个条件为真，然后根据这个观察结果采用相应的动作，但事实上，在你观察到这个结果以及开始相应操作时，观察结果可能变得无效，从而导致各种问题。


##### 状态一致性：要想保持状态一致性，就需要在单个院子操作中更新所有相关的状态变量。


##### 内置锁： 用来支持原子性，同步代码块包括两部分：(1) 一个作为锁的对象引用 (2)作为这个锁保护的代码块

以关键字synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁或者监视器器锁。线程进入同步代码块之前会自动获得锁，并且在退出同步代码块是自动释放锁，而无论是正常的控制路径退出，还是通过从代码块中抛出异常退出。

java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁。

##### 重入机制： 当某个线程请求一个由其他线程持有锁时，发出请求的线程就会阻塞。但是，如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作粒度是“线程”而不是“调用”。

重入机制的实现方式：为每个锁关联一个获取*计数值*和一个*所有者线程*。当计数值为0时，这个锁就被认为是没有被任何线程所有。当线程请求一个未没有被任何线程持有的锁时，JVM将几下持有者，并且将获取的计数值置为1.如果同一个线程再次获得这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为0时，这个锁将被释放。

### 对象的共享


---

##  结构化并发应用程序

### 构建模块



---
##  高级主题
