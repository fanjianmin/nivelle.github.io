---
layout: post
title:  "多线程学习"
date:   2017-05-09 00:06:05
categories: 技术
tags: 多线程
excerpt: 多线程深入学习
author: nivelle
---

* content
{:toc}

##  核心概念

### 线程的安全性

##### 线程安全：核心在于对状态访问进行管理，特别是对共享的和可变的状态的访问，一个对象是否需要是线程安全的，取决于它是否被多个线程访问，指的是在程序中访问对象的方式，而不是对象要实现的功能。当多个线程访问某个类时，这个类始终表现出真确的行为，那么就称这个类是线程安全的。

```
如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
 - 不在线程之间共享该状态变量
 - 将状态变量修改为不可变的变量
 - 在访问状态变量时使用同步
```
---

##### 线程安全的类：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

---

##### 对象的状态： 指的是存储在状态变量(例如实例或静态域)中的数据。对象的状态可能包括其他依赖对象的域。

```
无状态对象一定是线程安全的。

```
---

##### 竞态条件： 最常见的竞态条件类型就是“先检查后执行”。首先观察到某个条件为真，然后根据这个观察结果采用相应的动作，但事实上，在你观察到这个结果以及开始相应操作时，观察结果可能变得无效，从而导致各种问题。

---

##### 状态一致性：要想保持状态一致性，就需要在单个院子操作中更新所有相关的状态变量。

---

##### 内置锁： 用来支持原子性，同步代码块包括两部分：(1) 一个作为锁的对象引用 (2)作为这个锁保护的代码块

以关键字synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁或者监视器器锁。线程进入同步代码块之前会自动获得锁，并且在退出同步代码块是自动释放锁，而无论是正常的控制路径退出，还是通过从代码块中抛出异常退出。

java的内置锁相当于一种互斥体，这意味着最多只有一个线程能持有这种锁。

---

##### 重入机制： 当某个线程请求一个由其他线程持有锁时，发出请求的线程就会阻塞。但是，如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作粒度是“线程”而不是“调用”。

重入机制的实现方式：为每个锁关联一个获取**计数值**和一个**所有者线程**。当计数值为0时，这个锁就被认为是没有被任何线程所有。当线程请求一个未没有被任何线程持有的锁时，JVM将几下持有者，并且将获取的计数值置为1.如果同一个线程再次获得这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应的递减。当计数值为0时，这个锁将被释放。

---

##### 用锁来保护状态

如果使用同步来协调对某个变量的访问时，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量所有位置上都要使用同一个锁。但对象的内置锁与其状态之间并没有内在的联系。

当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象锁之后，只能阻止其他线程获得同一个锁，

```
对于可能被多个线程同时访问的可变状态变量，在访问它的时候都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量只应该由一个锁来保护，从而使维护人员知道是哪一个锁。
```
###### 常见加锁约定

将所有的可变状态封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会放生并发访问。

```
对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

```
###### 活跃性与性能

原则：尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享状态。

```
当执行时间较长的计算或者可能无法快速完成的操作时(例如，网络I/O或者控制台I/O)一定不要持有锁。

```


### 对象的共享

##### 可见性

单线程中，如果向某个变量写入值，然后在没有其他写入操作的情况下读取这个变量，那么总能得到相同的值。但是如果读写线操作在不同的线程中时，为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。



```
在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的顺序进行判断，几乎无法得出正确的结论。

```
---
非原子的64位操作：

java内存模型要求，变量的读取和写入操作必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。在多线程程序中使用共享可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明他们。

---

##  结构化并发应用程序

### 构建模块



---
##  高级主题
