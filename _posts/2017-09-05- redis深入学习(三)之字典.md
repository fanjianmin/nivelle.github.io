---
layout: post
title:  "redis深入学习(三)之字典"
date:   2017-09-04 01:06:05
categories: noSQL
tags: redis
excerpt: redis
---


* content
{:toc}

### 字典定义以及应用

字典,又称为符号表,关联数组或映射,是一种用于保存键值对的抽象数据结构.字典中,一个键可以和一个值进行关联,这些关联的键和值就称为键值对.

字典中的每个键都是独一无二的,程序可以在字典中根据键查找与之关联的值,或通过键里更新值,或根据键来删除整个键值对.

redis的数据库就是使用字典作为底层实现的,对数据库的增删查改操作也是构建在对字典的操作之上的.字典还是哈希键的底层实现之一,当一个哈希键包含的键值对比较多,又或者键值对中的元素都是比较长的字符串时,redis就会使用字典作为哈希键的底层实现.


### 字典实现

Redis的字典使用哈希表作为底层实现,一个哈希表里面可以有多个哈希表节点,而每个哈希表节点就保存了字典中的一个键值对.

```
typedef struct dictht{
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码,用于计算索引值
    //总是等于size-1
    unsigned long sizemask;
    //哈希表已有节点的数量
    unsigned long used;
}dictht;

```
table属性是一个数组,数组中的每个元素都是一个指向dict.h/dictEntry结构的指针,每个dictEntry结构保存着一个键值对.size属性记录了哈希表的大小,也即table数组的大小,而user属性则记录了哈希表目前已有节点的数量.sizemask属性的值总是等于size-1,这个属性和哈希值一起决定一个键应该被放到table数组的那个索引上面.

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E5%93%88%E5%B8%8C%E8%A1%A8.png)

#### 哈希表节点

哈希表节点使用dictEntry结构表示,每个dictEntry结构都保存着一个键值对:

```
typedef  struct dictEnty{
    //键
    void * key;
    //值
    union{
        void *val;
        uint64_tu64;
        int64_ts64;
    }v;
    //指向下个哈希表节点,形成链表
    struct dictEntry *next;
}dictEntry;


```

key属性保存着简直对中的键,而v属性则保存着键值对中的值,其中键值对的值可以是一个指针,或者是一个uint64_t整数,又或者是一个int64_t整数.

next属性是指向另一个哈希表节点的指针,**这个指针可以将多个哈希值相同的键值对连接在一次,以此来解决键冲突的问题**

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%AD%97%E5%85%B8.png)

#### 字典

```
typedef struct dict{
    //类型特定函数
    dictType * type;
    //私有数据
    void *privadata;
    //哈希表
    dictht ht[2];
    //rehash 索引
    //当rehash不在进行时,值为-1
    int trehashidx;
}

```

type属性和privadata属性是针对不同类型的键值对,为创建多态字典而设置的:

- type属性是一个指向dictType结构的指针,每个dictType结构保存了一簇用于操作特定类型键值对的函数,redis会为用途不同的字典设置不同的类型特定函数.

- privdata属性则保存了需要传给那些类型特定函数的可选参数

![image](http://7xpuj1.com1.z0.glb.clouddn.com/dictType.png)

ht属性是一个包含两个项的数组,数组中的每个项都是一个dictht哈希表,一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用.

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E6%99%AE%E9%80%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E5%AD%97%E5%85%B8.png)


### 哈希算法

当要将一个新的键值对添加到字典里面时,程序要先根据键值对的键计算出哈希值和索引值,然后再根据索引值,将包含新键值对的哈希表节点放到哈希表数组的指定索引上面.

#### 使用字典设置的哈希 函数,计算键key的哈希值索引值

hash = dict->type->hashFunction(key);
#### 使用哈希表的sizemask属性和哈希值,计算出索引值
###### 根据情况不同,ht[x]可以是ht[0]或者ht[1]
index = hash & dict->ht[x].sizemask;


### 解决键冲突

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时,我们称这些键发生了冲突.

redis的哈希表使用链地址法来解决键冲突,每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表,被分配到同一个索引上的多个节点可以用这个单向链表连接起来,这就解决了键冲突的问题.

例如:k2和v2添加到下图hash表里面,并且计算出k2的索引值为2,那么k1和k2将产生冲突,而解决冲突的方法就是使用next指针将k2和k1所在的节点连接起来.


![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E9%93%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81.png)

### rehash

为了让hash表的负载因子维持在一个合理范围之内,当哈希表保存的键值对数量太多或太少时,程序需要对哈希表的大小进行相应的拓展或收缩.

拓展和收缩哈希表的工作交由rehash操作来完成,redis对字典的哈希表执行rehash的步骤如下:

