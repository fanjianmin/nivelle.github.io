
---
layout: post
title:  "索引学习"
date:   2017-04-23 00:06:05
categories: mysql
tags: 学习
excerpt: 索引学习
---


* content
{:toc}



# 最近因为sql执行效率的问题老闯祸，所以把常用到的索引知识总结下


1. 复合索引：

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 

2. 排序中的索引：

mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。

3. like语句中的索引

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 

4. exists 使用方法

执行原理是 
a.首先执行一次外部查询 b.对于外部查询中的每一行分别执行一次子查询而且每次执行子查询时都会引用外部查询中当前行的值。 
c.使用子查询的结果来确定外部查询的结果集。
* 建立索引的时候，要在内部建立，外部建立的索引是不起作用的。

5. not IN 和not Exists

如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not Exists都比not IN要快。


---


- <，<=，=，>，>=，BETWEEN，IN 会使用索引

- <>，not in ，！=   则不能够使用索引

- WHERE index=1 OR A=10  也会是索引失效

- 存了数值的字符串类型字段（如手机号），查询时记得不要丢掉值的引号
 
- 查询条件中尽量使用常量，不要使用函数，也不要进行运算，否则无法使用索引
- 例如：
 以下不能使用索引
- SELECT * FROM user WHERE DATE(created_at) = ‘2014-01-01’;
- SELECT * FROM user WHERE (age-5) = 20;


- 联合索引时,遵循最左前缀原则
 例如 (如INDEX(nickname,city), 
 
 ```
 则以下能使用索引
SELECT * FROM user WHERE nickname=’aiddroid’;
SELECT * FROM user WHERE nickname=’aiddroid’ AND city = ‘广州’;
以下不能使用索引
SELECT * FROM user WHERE city = ‘广州’;

```

- MySQL查询只使用一个索引，因此如果where子句中已经使用了索引，那么order by中的列不再会使用索引
- ORDER BY 使用索引优化时
###### SELECT到的列需要有索引，直接SELECT 可能导致用不到索引优化，必要时可以FORCE INDEX
###### 如果ORDER BY多个字段，排序方向一致才能用到索引优化（ASC，DESC混用，无法使用索引优化）
###### GROUP BY时，条件需要有索引，多个条件时同样遵循最左前缀原则，必要时可以使用LIMIT


---


