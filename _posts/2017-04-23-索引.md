
---
layout: post
title:  "高性能mysql"
date:   2017-05-04 00:06:05
categories: mysql
tags: 技术
excerpt: mysql
---


* content
{:toc}



## 最近在看《高性能mysql》，总结下读书笔记


 ==**索引实在存储引擎实现的，MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则通过主键引用被索引的行。**==


## . 复合索引：

只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 

## .聚簇索引
- 首先，聚簇索引不是一种索引类型，而是一种数据存储方式，InnoDB的聚簇索引实际是在同一个结构中保存了B—Tree索引和数据行。
- 当表有聚簇索引时，它的数据实际存放在索引的叶子页中。无法同时把数据行存在两个不同的地方，所以一个表只有一个聚簇索引。（叶子页包含了全部的数据，节点页只包含了索引列）
### 优点：更快，可直接获取页节点中的主键值。（InnoDB索引的数据指的是主键值）
### 缺点：过犹不及（都放在内存，顺序就不重要了），插入速度严重依赖顺序，

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%7BI5Q%7B%29DVRO3ED5%7BIFTL%2843C.png)

### 最好避免随机的聚簇索引，特别是对I/O密集型的应用。从性能角度，uuid作为聚簇索引会很糟糕：他使得聚簇索引的插入变得随机，使数据没有任何聚集特性。

------------

## 覆盖索引

定义：如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”

### 优点：
- 极大地减少数据访问量
- 索引是按照列值顺序存储的（至少单页内是如此），对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据I/O要少的多
- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。
- 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

==注意==： select * 查询一般无法做覆盖查询，但是可以利用一个捷径：where 条件中的列是有索引可以覆盖
#### 当发起一个被索引覆盖的查询时，在EXPLAIN 的Extra列可以看到“Using Index”的信息。


## . 排序中的索引：

##### mysql有两种方式生成有序的结果：通过排序操作；或者按照索引顺序扫描。如果expian 出来的type 列的值为“index”则说明使用可索引扫描来做排序。



mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引，页分裂问题，全表扫描变慢，尤其是比较稀疏的时候，二级索引更大（二级索引的叶子节点包含了引用行的主键列，二级索引访问需要两次索引查找）

## . like语句中的索引

一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 

## . exists 使用方法

执行原理是 
a.首先执行一次外部查询 b.对于外部查询中的每一行分别执行一次子查询而且每次执行子查询时都会引用外部查询中当前行的值。 
c.使用子查询的结果来确定外部查询的结果集。
* 建立索引的时候，要在内部建立，外部建立的索引是不起作用的。

## . not IN 和not Exists

如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not Exists都比not IN要快。


---

- MySQL查询只使用一个索引，因此如果where子句中已经使用了索引，那么order by中的列不再会使用索引


## - ORDER BY 使用索引优化时

###### SELECT到的列需要有索引，直接SELECT 可能导致用不到索引优化，必要时可以FORCE INDEX
###### 如果ORDER BY多个字段，排序方向一致才能用到索引优化（ASC，DESC混用，无法使用索引优化）
###### GROUP BY时，条件需要有索引，多个条件时同样遵循最左前缀原则，必要时可以使用LIMIT


### 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。




## 一般mysql 能够使用如下三种方式应用where条件：

1. 在索引中使用where 条件来过滤不匹配的记录。存储引擎内完成的

2. 使用索引覆盖扫描（在Extra列中出现了using index ）来返回记录，直接从索引中过滤掉不需要的记录并返回命中结果。这是在mysql服务器完成的，但无需回表查询记录。

3. 从数据表中返回数据，然后过滤掉不满足条件的记录（在Extra列中出现using where）这在mysql服务器层完成，先从数据表读出记录，然后过滤。


## 
一个包含查询所需的字段的索引称为 covering index 覆盖索引。MySQL只需要通过索引就可以返回查询所需要的数据，而不必在查到索引之后进行回表操作，减少IO，提供效率。
   当你对一个sql 使用explain statement 查看一个sql的执行计划时，在EXPLAIN的Extra列出现Using Index提示时，就说明该select查询使用了覆盖索引。
   
   
## 索引使用注意

- <，<=，=，>，>=，BETWEEN，IN 会使用索引

- <>，not in ，！=   则不能够使用索引

- WHERE index=1 OR A=10  也会是索引失效

- 存了数值的字符串类型字段（如手机号），查询时记得不要丢掉值的引号
 
- 查询条件中尽量使用常量，不要使用函数，也不要进行运算，否则无法使用索引
- 例如：
 以下不能使用索引
- SELECT * FROM user WHERE DATE(created_at) = ‘2014-01-01’;
- SELECT * FROM user WHERE (age-5) = 20;


- 联合索引时,遵循最左前缀原则
 例如 (如INDEX(nickname,city), 
 
 则以下能使用索引
SELECT * FROM user WHERE nickname=’aiddroid’;
SELECT * FROM user WHERE nickname=’aiddroid’ AND city = ‘广州’;
以下不能使用索引
SELECT * FROM user WHERE city = ‘广州’;


## 高性能索引策略

- 独立的列：索引列不能是表达式的一部分，也不能是函数的参数。
- 前缀索引和索引选择性：通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。唯一索引的选择性是1，这是最好的选择性，性能也是最好的。前缀索引是一种是索引更小、更快的方法，但是缺的是：无法使用前缀索引做oreder by 和group by,也无法使用前缀索引做覆盖扫描。
 
### 索引合并策略

在多个列上建立独立的单列索引大部分情况下并不能提高mysql的查询性能。5.0版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上多个单列索引来定位指定的行。能够同时使用多个单列进行扫描，并将结果进行合并。

索引合并是一种优化结果，其实说明了索引建的有问题，需要考虑如下问题：

- 当出现服务器对多个索引做相交操作时（多个and），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的索引。
- 当服务器对多个索引做联合操作时（多个or）,通常需要耗费大量的cpu和内存资源在算法的缓存、排序和合并操作上。特别是有些索引选择性不高，需要合并扫描返回大量数据的时候。
- 优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。使得成本被低估。不但消耗更多cpu和内存资源，还可能导致查询的并发性，但单独运行这样的查询往往忽略并发性影响。不如改写成union方式。


######  optimizer_switch 可关闭索引合并，ingore index 忽略掉某些索引。


## 选择合适的索引列顺序

- 多列B-tree中，顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。
- 对于如何选择索引顺序有个经验法则：当不需要考虑排序和分组时，将选择性最高的列放在最前列很好。这时只需要优化where 条件的查询。（根据具体的情况调整顺序，将选择性更高的排到前面）
- 

更新中。。。
