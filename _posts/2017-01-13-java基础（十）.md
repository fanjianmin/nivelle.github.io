---
layout: post
title:  "java基础(十)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 持有对象

在写程序时不知道将需要多少个对象,或者是否需要更复杂的方式来存储对象来存储对象,若用固定大小的数组来存储,就明显受限了.

java实用类库提供了一套完整的容器类解决这个问题,其中基本的类型是List,Set,Queue和Map.这些对象称为集合类,但由于java的类库中使用了Collection这个名字来指代该类库的一个特殊子集,所以我们使用了范围更广的称呼"容器".

#### 泛型和类型安全的容器

Object默认的toString()方法,将打印类名,后面跟随该对象的散列码的无符号十六进制表示.

#### 基本概念

java容器类类库的用途是"保存对象",并将其划分为不同的概念:

- Collection:一个独立元素的序列,这些元素都服从一条或者多条规则.List必须按照插入的顺序保存元素,而set不能有重复元素.Queue按照排队规则来确定对象产生的顺序(通常与插入的顺序相同)
- Map:一组成对的"键值对"对象,允许你使用键来查找值.映射表允许我们使用另一个对象来查找某个对象,它也被称为"关联数组",因为它将某些对象与另外一些对象关联在了一起;或者称为"字典",因为你可以使用键对象来查找值对象.


Collection接口概括了序列的概念:一种存放一组对象的方式.

```

import java.util.ArrayList;
import java.util.Collection;

public class SimpleCollection {
  public static void main(String[] args) {
    Collection<Integer> c = new ArrayList<Integer>();
    for (int i = 0; i < 10; i++) {
      c.add(i);
    }
    for (Integer i : c) {
      System.out.print(i);
    }
  }
}

```

因为这个示例只使用了Collection方法,因此任何继承自Collection的类的对象都可以正常工作,但是ArrayList是最基本的序列类型.

add()方法的名称就表明它是将一个新元素放置到Collection中.但是,文档中非常仔细地叙述到:"要确保这个Collection包含指定的元素".这是考虑到了set的含义,因为在set中只有元素不存在的情况下才会添加.在使用ArrayList,或者任何类的List时,add()总是表示把他放进去,因为list不关心是否存在重复.

#### 添加一组元素

- Arrays.asList()接受一个数组或是一个用逗号分隔的元素列表(使用可变参数),将其转变成为一个List对象.

- Collection.addAll()方法接受一个Collection对象,以及一个数组或是一个逗号分隔的列表,将元素添加到Collection.

```
package learn;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;

public class AddingGroups {
  public static void main(String[] args) {
    Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));
    Integer[] moreInts = { 6, 7, 8, 9, 10 };
    collection.addAll(Arrays.asList(moreInts));

    Collections.addAll(collection, 11, 12, 13, 14, 15);

    List<Integer> list = Arrays.asList(16, 17, 18, 19, 20);
    collection.addAll(list);
    for (Integer i : collection) {
      System.out.print(i + ",");
    }
  }
}


```

Collection的构造器可以接受另一个Collection,用它来将自身初始化,因此你可以使用Arrays.List()来为这个构造器产生输入.但是,Collection.addAll()方法运行起来要快的多,而且构建一个不包含元素的Collection,然后调用Collection.add()这种方式很方便,因此它是首选.


#### 容器的打印

你必须使用Arrays.toString()来产生数组的可打印表示,但是打印容器无需任何帮助.

```
package learn;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

public class PrintingContainers {
  static Collection<String> fill(Collection<String> collection) {
    collection.add("rat");
    collection.add("cat");
    collection.add("dog");
    collection.add("dog");
    return collection;
  }
  static Map<String,String> fill(Map<String, String> map){
    map.put("rat", "Fuzzy");
    map.put("cat", "Rags");
    map.put("dog", "Bosco");
    map.put("dog", "Spot");
    return map;
  }
  public static void main(String[] args) {
    System.out.println(fill(new ArrayList<String>()));
    System.out.println(fill(new LinkedList<String>()));
    System.out.println(fill(new HashSet<String>()));
    System.out.println(fill(new TreeSet<String>()));
    System.out.println(fill(new LinkedHashSet<String>()));
    System.out.println(fill(new HashMap<String,String>()));
    System.out.println(fill(new TreeMap<String,String>()));
    System.out.println(fill(new LinkedHashMap<String,String>()));
  }
}


```
结果:

[rat, cat, dog, dog]

[rat, cat, dog, dog]

[cat, dog, rat]

[cat, dog, rat]

[rat, cat, dog]

{cat=Rags, dog=Spot, rat=Fuzzy}

{cat=Rags, dog=Spot, rat=Fuzzy}

{rat=Fuzzy, cat=Rags, dog=Spot}

---

默认的打印行为,使用容器提供的toString()方法,即可生成可读性很好的结果.Collection打印出来的内容用方括号扩住,每个元素由逗号分隔.Map则用大括号扩住,键与值由等号联系.

---

ArrayList和LinkedList都是List类型,它们都是按照被插入的顺序保存元素. HashSet,treeSet,和LinkedHashSet都是Set类型.HashSet使用的是相当复杂的方式来存储元素的,这种技术是最快的获取元素的方式,因此,存储的顺序看起来并无实际意义.如果存储顺序很重要,那么可以使用TreeSet,它可以按照升序保存对象,或者使用LinkedHashSet,它按照被添加的顺序保存对象.

---

Map(关联数组)使得你可以用键来查找对象,就像一个简单的数据库.不必指定Map的尺寸,因为它自己会自动调整尺寸.Map还知道如何打印自己,它会显示相关联的键和值.HashMap提供了最快的查找技术,也没有按照任何顺序来保存其元素,TreeMap按照比较结果的升序保存键,而LinkedHashMap则按照插入保存键,同时还保留了HashMap的查询速度.

### List

承诺将元素维护在特定的序列中,List接口在Collection的基础上添加了大量的方法,使得可以在List的中间插入和移除元素.

- ArrayList,长于随机访问元素,但是在List中间插入和移除元素时较慢.

- LinkedList,它通过代价较低的在list中间进行的插入和删除操作,提供了优化的顺序访问.LinkedList在随机访问方面比较慢,但是的的特性集较ArrayList.

---

可以用contains()方法来确定某个对象是否在列表中,如果移除某个对象,则可以将这个对象的引用传递给remove()方法.同样如果有一个对象的引用,则可以使用indexOf()来发现该对象在List中所处位置的索引编号.

subList()方法允许你很容易地从较大的列表中创建一个片段,而将这个结果传递给较大列表的containsAll()方法时,自然会得到true.

### 迭代器

迭代器的概念可以用于实现切换不同的容器,迭代器是一个对象,它的工作是遍历并选择序列中的对象,而客户端程序员不必知道或关系该序列底层的结构.此外,迭代器被称为轻量级对象:创建它的代价小.Iterator的功能:

- 使用Iterator()要求容器返回一个Iterator.Iterator将准备好返回序列的第一个元素.

- 使用next()获得序列中的下一个元素.

- 使用hasNext()检查序列中是否还有元素.

- 使用remove()将迭代器新近返回的元素删除.

```

public class SimpleIteration{
  
  public static void main(String args[]){
     List<Pet> pets = Pets.arrayList(12);
     Iterator<Pet> it = pets.iterator();
     while(it.hasNext()){
        Pet p = it.next();
        System.out.println(p.id()+":"+p+" ");
     }
  }
}

```

---


接受对象容器并传递它,从而在每个对象上都执行操作,这种思想十分强大,并且贯穿于本书.

```
public static void display(Iterator<pet> it){
  while(it.hasNext()){
    Pet it = it.next();
  }
}

```

### ListIterator

ListIerator 是一个更强大的Iterator子类型,只能用于各种List类的访问.尽管Iterator只能向前移动,但是ListIterator可以双向移动,它还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引,并且可以使用set()方法替换它访问过的最后一个元素.可以通过调用ListIterator()方法产生一个指向List开始出的ListIterator,并且还可以通过调用ListIterator(n)创建一个一开始就指向列表索引为n的元素处的ListIterator.


```
package learn;

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

public class ListFeatures {

  public static void main(String[] args) {
    List<Pet> pets = new ArrayList<Pet>();
    pets.add(new Pet(1, "cat"));
    pets.add(new Pet(2, "dog"));
    
    ListIterator<Pet> it = pets.listIterator();
    while(it.hasNext()){
      System.out.println(it.next());
      System.out.println(it.nextIndex()+","+it.previousIndex());
    }
    System.out.println();
    while(it.hasPrevious()){
      System.out.println(it.previous().getId()+"");
    }
    System.out.println(pets);
    it = pets.listIterator(1);
    while(it.hasNext()){
      it.next();
      it.set(new Pet(3, "fish"));
    }
    System.out.println(pets);
  }

}

class Pet {
  private int id;
  private String name;

  public int getId() {
    return id;
  }

  public void setId(int id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Pet(int id, String name) {
    this.id = id;
    this.name = name;
  }
  
  @Override
  public String toString(){
    
    return "id:"+id+"  "+"name:"+name;
    
}
}

```

结果:

id:1  name:cat

1,0

id:2  name:dog

2,1

2

1

[id:1  name:cat, id:2  name:dog]

[id:1  name:cat, id:3  name:fish]


### LinkedList
