---
layout: post
title:  "事物学习"
date:   2017-06-05 00:06:05
categories: 技术
tags: 事物
excerpt: 事物
author: nivelle
---


* content
{:toc}


#### 事物

定义：以可控的方式对数据资源进行访问的一组操作。为了保证事物执行前后数据资源所承载的系统始终处于正确状态，事物持有四个特性来实现这个目的：

- 原子性：事物所包含的全部操作是一个不可分割的整体，这些操作要么全部提交成功，要么只要其中的一个失败，就全部失败。
- 一致性：事物所包含的操作不能违反数据资源的一致性检查，数据资源在事物执行前处于某个数据一致性状态，那么事物执行之后依然需要保持数据间的一致性状态。
- 隔离性：事物的隔离性主要规定了各个事物之间相互影响的程度，隔离性的概念主要主要面对数据资源的并发访问，并兼顾影响事物的一致性。当两个事物或者更多事物同时访问同一个数据资源的时候，不同的隔离级别决定了各个事物对该数据资源访问的不同行为。4种类型的隔离级别：

    - Read Uncommitted:最低隔离级别。它最直接的效果就是 ，**一个事物可以读取另一个事物没有提交的更新结果**。Read Uncommitted是以较低的隔离度来寻求较高的性能，其本身面临以下问题：
   
     （1）脏读：如果一个事物对数据进行了更新，但事物还没提交，另一事物就可以看到该事物没有提交的更新结果。如果第一个事物回滚，那么第二个事物在此之前读到的数据就是一笔脏数据。

     （2）不可重复读：不可重复读指的是通一个事物在整个事物过程中对同一笔数据进行读取，每次读取的结果都不同。如果事物1在事物2的更新操作之前读过一次数据，在事物2的更新操作之后再读取同一笔数据一次，两次结果是不同的。
  
     （3）幻读：指的是同样一个查询在整个事物过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下，不管事物2的插入操作是否提交，事物1在插入操作之前和之后执行相同的查询，取得的结果集是不一样的。
 
   - Read Committed：大部分数据库采取的默认隔离级别，他比Read Uncommitted隔离级别拥有更高级别的限定。一个事物的更新操作结果只有在该事物提交之后，另一个事物才能读到同一笔数据更新后的结果。所以它可以避免脏读问题。 
   - Repeatable Read：它保证在事物的整个过程中，对同一笔数据的读取结果是相同的，不管其他事物是否同时在对同一笔数据进行更新，也不管其他事物对同一笔数据的更新提交与否。它能够避免脏读和不可重复读，但是无法避免幻读。
   - Serializable:它是最严格的隔离级别。所有事物都一次执行，可以避免其他隔离级别遇到的所有问题，是最安全的隔离级别。但是我们通常会使用其他隔离级别加上相应的并发锁的机制来控制对数据的访问，这样能保证系统的性能损失不会太大，也能够在一定程度山保证数据一致性。
    ![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E4%BA%8B%E7%89%A9.png) 

- 持久性：一旦整个事物操作成功提交，对数据所做的变更将被记载并不可逆转。


#### 事物中的概念

- Resource Manager：简称RM.负责存储并管理系统数据资源的状态，比如数据库服务器，JMS消息服务器等。
- Transaction Processing Monitor：它负责在分布式事物场景中协调包含多个RM的事物处理。J2EE规范中的应用服务器（Application Server）担当的就是这个角色。
- Transaction Manager：简称TM,它可以使TP Monitor中的核心模块，直接负责多RM之间事物处理的协调工作，并提供事物界定（Transaction Demarcation）、事物上下文传播（Transaction Context Propagation）等功能接口。
- Application:以独立形式存在的或者运行于容器中的应用程序，可以认为是事物边界的触发点。实际上，并非每个事物的场景中都会出现以上提到的所有参与者，如果根据整个事物中涉及的RM的多寡来区分事物的话，可分为两类：全局事物，局部事物。

（1）全局事物：如果整个事物处理过程中由多个RM参与，那么就需要引入TP Monitor来协调多个RM之间的事物处理处理。TP Monitor将采用两阶段提交（Two-Phase Commit）协议来保证整个事物的ACID属性。这种场景下的事物，就称为全局事物或者分布式事物。
![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E5%85%A8%E5%B1%80%E4%BA%8B%E7%89%A9.png)

（2）局部事物：如果当前事物只有一个RM参与其中，我们就可以称当前事物为局部事物。比如在当前事物中只对一个数据库更新，或者只向一个消息队列中发送消息的情况，都属于局部事物。
![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E5%B1%80%E9%83%A8%E4%BA%8B%E7%89%A9.png)

#### Spring事物框架

Spring 事物框架设计理念基本原则是：让事物管理的关注点与数据访问关注点分离。

- 当在业务层使用事物的抽象API进行事物界定的时候，不需要关系事物将要加诸于上的事物 资源是什么，对不同的事物资源的管理将由相应的框架实现类来操心。
- 当在数据访问层对可能参与事物的数据资源进行访问时，只需要使用相应的数据访问API进行数据访问，不需要关心当前的事物资源如何参与事物或者是否需要参与事务。这同样将由事物框架类来打理。

以上两个关注点被清晰地分离出来之后，对于开发人员来说，唯一需要关心的，就是通过抽象后的事物管理API对当前事物进行界定而已：

```
public class FooService
{
     private PlatformTransactionManager transactionManager;
     
     public void serviceMethod()
     {
         TransactionDefinition definition =...;
         
         TransactionStatus txStatus = getTransactionManager().getTransaction(definition);
         try
         {
             //dao1.doDataAccess();
             //dao2.doDataAccess();
         }catch(DataAccessException e)
         {
            getTransactionManager.rollback(txStatus) ;
            throw e;
         }
         getTransactionManager().commit(txStatus);
     }
     
     public PlatformTransactionManager getTransactionManager(){
         return transactionManager;
     }
     
     public void setTransactionmanager(PlatformTransactionManager transactionManager)
     {
         this.transactionmanager=transactionmanager;
     }
}

```
##### spring 事物核心接口

- PlatformTransactionManager:为应用程序提供事物界定的统一方式，是整个事物抽象策略的顶层接口。

```
public interface PlatformTransactionManager{
    TransactionStatus getTransaction(TransactionDefinition definition) throws Transaction Exception;
    
    void commit(TransactionStatus status) throws TransactionException;
    
    void roolback(TransactionStatus) throws TransactionException;
}

```

spring 的事物框架针对不同的数据访问方式以及全局事物场景，提供相应的PlafformTransactionManager实现类。例如JDBC数据访问方式的局部事务为例，我们通常将事物管理层放在Service层，而将数据访问逻辑放在DAO层。

因为JDBC的局部事务控制是同一个java.sql.Connection来完成的，所以保证两个DAO的数据访问方法处于同一个事务中，我们就得保证他们使用的是同一个java.sql.Connection.要做到这一点，通常会采用称为connection-passing的方式，即为同一个事务中的各个dao的数据访问方法传递当前事务对应的同一个java.sql.Connection.这样，我们的业务方法以及数据访问方法都得做一定修改：


普通情况下的事物管理代码：

```
public void serviceMetod()
{
Object txObject = transactionManaget.beginTransaction();
...
dao1.doDataAccess();
dao2.doDataAccess();
...
transactionManager.commitTransaction(txObjct);
}

```
![image](http://7xpuj1.com1.z0.glb.clouddn.com/connect-passing.png)

要传递java.sql.Connection,我们可以将整个事物对应的java.sql.Connection实例放到统一的一个地方去，无论是谁，要使用该资源，都从这个地方来获取，这样就解除了事务管理代码和数据访问代码直接通过java.sql.Connection的直接耦合。具体点儿说，我们在事务开始之前取得一个java.sql.Connection,然后将这个Connection绑定到当前的调用线程。之后，数据访问对象在使用Connection进行数据访问的时候，就可以从当前线程上获得这个事务开始的时候绑定的Connection实例。当所有数据访问对象全部
使用这个绑定到当前线程的Connection完成了数据访问工作时，我们就使用这个Connection实例提交或者回滚事务，然后解除它到当前线程的绑定。


#### 分布式事物
