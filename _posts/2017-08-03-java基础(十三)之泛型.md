---
layout: post
title:  "java基础(十三)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 泛型

泛型的主要目的就是用来指定容器要持有什么类型的对象,而且由编译器来保证类型的正确性.

与其使用Object,我们更喜欢暂时不指定类型,而是稍后再决定具体使用什么类型.达到这个目标,需要使用类型参数,用尖括号扩住,放在类名后面.然后在使用这个类的时候,再用实际的类型替换此类型参数.

```
public class Holder<T> {
    private T a;
    public Holder (T a){this.a=a;}
    public void set(T a){this.a=a;}
    public T get(){return  a;}
    public static  void main(String args[]){
        Holder<Automobile> h3 = new Holder<Automobile>(new Automobile("nivelle"));
        Automobile a = h3.get();
        System.out.println(a);
    }

}
class Automobile{
    public String value;
    public Automobile(String string){
        this.value=string;
    }
    @Override
    public String toString(){
        return  value;
    }
}

```

现在创建Holder对象的时候就必须指定持有什么类型的对象,将其置于尖括号内.然后只能在Holder中存入该类型的对象,并且,从中取出它持有的对象时,自动地是正确的类型.


### 泛型接口

泛型也可以应用于接口.例如生成器,专门创建对象的类.它创建对象的时候不需要任何参数.一般而言,一个生成器定义一个方法,该方法用于产生新对象.

```
package genericity;

import java.util.Iterator;
import java.util.Random;
import java.util.concurrent.Exchanger;

/**
 * Created by nivelle on 2017/8/3.
 */
public class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee> {

    private Class[] types = {Latter.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class};

    private static Random rand = new Random(47);

    public CoffeeGenerator() {
    }

    private int size = 0;

    public CoffeeGenerator(int sz) {
        size = sz;
    }

    public Coffee next() {
        try {
            return (Coffee) types[rand.nextInt(types.length)].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    class CoffeeIterator implements Iterator<Coffee> {
        int count = size;

        public boolean hasNext() {
            return count > 0;
        }

        public Coffee next() {
            count--;
            return CoffeeGenerator.this.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    ;

    public Iterator<Coffee> iterator() {
        return new CoffeeIterator();
    }

    public static void main(String args[]) {
        CoffeeGenerator gen = new CoffeeGenerator();
        for (int i = 0; i < 5; i++) {
            System.out.println(gen.next());
        }
        for (Coffee c : new CoffeeGenerator(5)) {
            System.out.println(c);
        }
    }
}


```
