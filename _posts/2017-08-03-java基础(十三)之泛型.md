---
layout: post
title:  "java基础(十三)之泛型"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 泛型

泛型的主要目的就是用来指定容器要持有什么类型的对象,而且由编译器来保证类型的正确性.

与其使用Object,我们更喜欢暂时不指定类型,而是稍后再决定具体使用什么类型.达到这个目标,需要使用类型参数,用尖括号扩住,放在类名后面.然后在使用这个类的时候,再用实际的类型替换此类型参数.

```
public class Holder<T> {
    private T a;
    public Holder (T a){this.a=a;}
    public void set(T a){this.a=a;}
    public T get(){return  a;}
    public static  void main(String args[]){
        Holder<Automobile> h3 = new Holder<Automobile>(new Automobile("nivelle"));
        Automobile a = h3.get();
        System.out.println(a);
    }

}
class Automobile{
    public String value;
    public Automobile(String string){
        this.value=string;
    }
    @Override
    public String toString(){
        return  value;
    }
}

```

现在创建Holder对象的时候就必须指定持有什么类型的对象,将其置于尖括号内.然后只能在Holder中存入该类型的对象,并且,从中取出它持有的对象时,自动地是正确的类型.


### 泛型接口

泛型也可以应用于接口.例如生成器,专门创建对象的类.它创建对象的时候不需要任何参数.一般而言,一个生成器定义一个方法,该方法用于产生新对象.


```

public interface Generator<T> {

    T next();
}


```



```
package genericity;

import java.util.Iterator;
import java.util.Random;
import java.util.concurrent.Exchanger;

/**
 * Created by nivelle on 2017/8/3.
 */
public class CoffeeGenerator implements Generator<Coffee>, Iterable<Coffee> {

    private Class[] types = {Latter.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class};

    private static Random rand = new Random(47);

    public CoffeeGenerator() {
    }

    private int size = 0;

    public CoffeeGenerator(int sz) {
        size = sz;
    }

    public Coffee next() {
        try {
            return (Coffee) types[rand.nextInt(types.length)].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    class CoffeeIterator implements Iterator<Coffee> {
        int count = size;

        public boolean hasNext() {
            return count > 0;
        }

        public Coffee next() {
            count--;
            return CoffeeGenerator.this.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    ;

    public Iterator<Coffee> iterator() {
        return new CoffeeIterator();
    }

    public static void main(String args[]) {
        CoffeeGenerator gen = new CoffeeGenerator();
        for (int i = 0; i < 5; i++) {
            System.out.println(gen.next());
        }
        for (Coffee c : new CoffeeGenerator(5)) {
            System.out.println(c);
        }
    }
}


```

注意:this指的是当前正在访问这段代码的对象,当在内部类中使用this指的就是内部类的对象,为了访问外层类对象,就可以使用外层类名.this来访问,一般也只在这种情况下使用这种


参数化的Generator接口确保next()返回值是参数的类型.CoffeeGenerator同时还实现了Iterable接口,所以它可以在循环语句中使用.

### 泛型方法

指导原则:无论何时,只要能做到,就应该尽量使用泛型方法.也就是说,如果使用泛型方法可以取代将整个类泛型化,那么就应该只使用泛型方法.

对于一个static的方法而言,无法访问泛型类的类型参数,所以,如果static方法需要使用泛型能力,就必须使其成为泛型方法

```

public class GenericMethods {
    public <T> void  f(T x){
        System.out.println(x.getClass().getName());
    }
    public static  void main(String [] args){
        GenericMethods gm = new GenericMethods();
        gm.f("");
        gm.f(1);
        gm.f(1.0);
        gm.f(1.0F);
        gm.f('c');
        gm.f(gm);
    }
}


```

结果:

java.lang.String
java.lang.Integer
java.lang.Double
java.lang.Float
java.lang.Character
genericity.GenericMethods

---

当使用泛型类时,必须在创建对象的时候指定类型参数的值,而使用泛型方法的时候,通常不必指明参数类型,因为编译器会为我们们找出具体的类型.这称为类型参数推断.因此,我们可以像调用普通方法一样调用f(),而且就好像是f()被无限次地重载过.
