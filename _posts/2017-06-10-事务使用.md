---
layout: post
title:  "事务使用"
date:   2017-06-10 00:06:05
categories: 技术
tags: 事务
excerpt: 事务
author: nivelle
---


* content
{:toc}


###  编程式事务管理

通过Spring进行编程式事务管理有两种方式，要么直接使用PlatformTransactionManager，要么使用更方便的TransactionTemplate.

 - 直接使用PlatformTransactionManager
 
 ```
 DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
  
  definition.setTimeout(20);  
  ...
  TransactionStatus txStatus = TransactionManager.getTransaction(definition);

  trr{
    //业务逻辑实现
    
  }catch(ApplicationException e){
    TransactionManager.rollback(txStatus);
    throw e;
  }catch(RunTimeException e){
    TransactionManager.rollback(txStatus);
    throw e;
  }catch(Error e){
    TransactionManager.rollback(txStatus);
    throw e;
  }
  TransactionManager.commit();
  
 ```
 只要为transactionManager提供合适的PlatformTransactionManager实现，然后结合TransactionDefinition开启事务，并结合TransactionStatus来回滚或提交事务，就可以完成针对当前对象的整个事务管理。


 - 使用TransactionTemplate进行编程式事务管理

###  声明式事务管理

org.springframework.transaction.support.TransactionTemplatr对与PlatformTransactionManger相关的事务界定操作以及相关异常处理进行了模板化封装，开发人员更多地关注通过相应的Callback接口提供具体的事务界定内容即可。Spring针对TransactionTemplate提供了两个Callback接口，TransactionCallback和TransactionbackWithoutResult，二者唯一的区别是是否需要返回执行结果。
```
TransactionTemplate txTemplate = ...;

Object result = txTemplate.execute(new TransactionCallback(){
  public Object doInTraction(TransactionStatus txStatus){
     Object result =null;
     //各种事务操作
     return result;
  }
})

或者
txTemplate.execute(new TransactionCallbackWithoutResult(){
  @Override
  protected void  doInTransactionWithoutResult(TransactionStatus txStatus){
     // 事务操作1
     // 事务操作2
     //..
  }
})

```

TransactionTemplate会捕捉TransactionCallback或者TransactionCallbackWithoutResult事务操作中抛出的unchecked exception 并回滚事务，然后将unchecked exception 抛给上层处理。

所以，现在我们只需要处理特定于应用程序的异常即可，而不用直接使用PlatformTransactionManager那样，对所有可能的异常都进行处理。  


如果事务处理期间没有任何问题，TransactionTemplate最终会为我们提交事务，唯一需要我们干预的只剩下某些情况的事务回滚了。如果在TransactionCallback或者TransactionCallbackWithoutResult的事务操作过程中需要让当前事务回滚而不是最终提交，一般来说，我们有如下两种方式。
 
- 抛出unchecked exception ,TransactionTemplate会为我们处理事务回滚。如果事务操作中可能抛出checked exception,那么就得在callback内部捕获，然后转译为unchecked exception 后抛出。

```
txTemplate.execute(new TransactionCallbackWithoutResult(){
  @Override
  protected void doInTransactionWithoutResult(TransactionStatus txStatus){
   try{

     ...
   }catch(Che使用ckedException e){
     //抛出特定的异常类型以避免一般情况下使用RuntimeException
     throw new RuntimeException(e);
   }
  }
})

```

- 使用Callback接口公开的TransactionStatus将事务标记为rollBackOnly.TransactionTemplate在最终提交事务的时候，如果检测到rollBackOnly标志状态被设置，将把提交事务改为回滚事务。

```
txTemplate.execute(new TransactionCallbackWithoutResult(){
  @Override
  protected void doInTransactionWithoutResult(TransactionStatus txStatus){
    boolean needRollback = faallse;
    ...
    if(needRollback)

     txStatus.setRollbackOnly();

  }

})

```
对于事务操作中可能抛出的checked exception ,如果既想回滚事务，又不想让它以unchecked exceptin的形式向上层传播的话，我们可以通过TransactionStatus设置rollBackOnly来达到目的。

```
txTemplate.execute(new TranactionCallbackWithoutResult(){
  @Override
  protected void doInTransactionWithoutResut(TransactionStatus txStatus){

   try{
     ...
   }catch(CheckedException e){
     logger.warn("Transaction is Rolled back!",e);
     txStatus.setRollbackOnly();
   }
  }
})


```

限制：虽然使用TransactionTemplate比PlatformTransactionManager更加便捷，但TransactionTemplate无法处理当事物操作中需要向上抛出原来的checked exception的情况。在TransacionCallback或者TransactionCallbackWithoutResult的方法定义中没有声明抛出任何checked exception ,直接使用PlatformTransactionManager则没有这样的限制。

##### 编程创建基于Savepoint的嵌套事务

TrannsactionStatus不但可以在事务处理期间通过setRollbackOnly()方法来干预事务的状态，如果需要，作为SavepointManger,它可以帮助我们使用Savepoint机制来创建嵌套事务。

场景：银行账户转账，现在不是从一个账户转到另一个账户，而是从一个账户转到两个账户，一个主账户，一个备用账户。如果向主账户转账失败，则将金额转入备用账户。总之，金额从一个账户取出后，必须存入两个账户中的其中一个，以保证整个事物的完整性。

```
txTemplate.execute(new TransactionCallbackWithoutResult(){
  
  @Override
  protected void doInTransactionWithoutResult(TransactonStatus txStatus){

    try{
      withdraw("WITHDRAW_ACOUNT_ID",transferAmount);
      Bigdecimal tansferAmount = new BigDecimal("20000");
      try
      {
        deposit("WITHDRAW_ACOUNT_ID",transferAmount);

        Obejct savePointBeforeDeposit = txStatus.createSavepoint();
        try{
           deposit("WITHDRAW_ACOUNT_ID",transferAmount);
        }catch(DepositExceon ex)
        {
          logger.warn("rollback to savepoint for main transfer failure",ex);
          txStatus.rollbackToSavepoint(savePointBeforeDeposit);
           deposit("WITHDRAW_ACOUNT_ID",transferAmount);
        }finall{
          txStatus.releaseSavePoint(savePointBeforeDeposit);
        }
      }
    }catch(TransferException e){
       logger.warn("failed to complete transfer operation!",e);
       txStatus.setRollbackonly();
    }
  }
})

```

这里，使用Savepint创建嵌套事务的好处是，即使deposit过程中涉及多笔数据的更新，通过txStatus.rolbackToSavepoint（savePointBeforeDeposit）也可以将这些数据恢复到没有存入金额之前的状态，而不会破坏当前事务的完整性。如果传播特性是PROPAGATION_REQUIRES_NEW的TransactionDefinition创建一个新的事务的话，虽然deposit过程中出现问题也可以回滚，但取款与存款的操作就不在同一个事务中了。



- XML元数据驱动的声明式事务

引子：事务管理本身就是一种横切关注点，与其他的横切关注点本质上一样，所以完全可以提供相应的Advice实现，然后织入到系统中需要该横切逻辑的Joinpoint处。提供一个拦截器，在业务方法执行开始之前开启一个事务，当方法执行完成或者异常退出的时候就提交事务或者回滚事务。有了Spring的编程式事务管理API的支持。

用于声明式事务管理的拦截器原型代码示例：

```

public class PrototypeTransactionInterceptor implements MethodInterceptor{
  
  private PlatformTransactionManager transactionManager;
  
  public Object invoke(MethodInvocation invocation) throws Throwable{
 
     Method method = invocation.getMethod();
     TransactionDefinition definition = getTransactionDefinitionByMethod(method);
     
     TransactionStatus txStatus = transactionManager.getTransaction(definition);
     
     Object result = null;
     try{
       result = invocation.proceed();
     }catch(Throwable t){
       if(needRollbackOn(t)){
         transactionManager.rollback(txStatus);
       }else{
         transactionManager.commit(txStatus);
       }
       throw toString();
     }
     transactionManager.commit(txStatus);
     return result;    
  }
  protected boolean needRollbackOn(Throwable t){
    //TODO 实现更多细节
    return false;
  }
  
  protected TransactionDefinition getTransactionDefinitionByMethod(Method method) {
    //TODO实现更多细节    
    return null;
  }
  
  public PlatformTransactonManager getTransactionManager(){
    return transactionManager;
  }
  
  public setTransactionManger(PlatformTransactionManager transactonManager){
    this.transactionManager = transactonManager;
  }
}

```


- 注解元数据驱动的声明式事务
