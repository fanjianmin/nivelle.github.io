---
layout: post
title:  "servlet原理解析"
date:   2016-09-17 00:06:05
categories: 技术
tags: servlet
excerpt: java
---


* content
{:toc}


### 定义


**Servlet 是Server + Applet 的缩写，表示一个服务器应用。**

Servlet与Servlet容器的关系类似枪和子弹的关系.枪是为子弹而生,而子弹让枪有了杀伤力.从技术角度来看是为了解耦,他们通过标准化接口来相互协作.

```
常见servlet容器:

- jetty:在定制化和移动领域
- tomcat

```
Tomcat的容器等级中,Context容器是直接管理Servlet在容器中的包装类Wrapper,所以Context容器如何运行将直接影响Servlet的工作方式.


![image](http://7xpuj1.com1.z0.glb.clouddn.com/tomcat%E7%AD%89%E7%BA%A7%E7%BB%93%E6%9E%84.jpg)

真正管理Servlet的容器是Context容器,一个Context对应一个web工程,在Tomcat的配置文件中可以很容易发现这一点

```
<Context path="/projectOne " docBase="D:\projects\projectOne"
reloadable="true" />

```

### Servlet容器的启动过程

Tomcat7也开始支持嵌入式功能,增加了一个启动类 org.apache.catalina.startup.Tomcat.创建一个实例对象并调用start方法就可以很容易启动Tomcat,我们还可以通过这个对象来增加和修改Tomcat的配置参数,如可以动态增加context,Servlet等.下面我们就利用这个Tomcat类来管理增加一个Context容器,我们选择Tomcat7自带的examples Web工程,并看它是如何加到这个Context容器中的.


Tomcat的addWebapp方法代码如下:

```
public Context addWebapp(Host host, String url, String path) { 
       silence(url); 
       Context ctx = new StandardContext(); 
       ctx.setPath( url ); 
       ctx.setDocBase(path); 
       if (defaultRealm == null) { 
           initSimpleAuth(); 
       } 
       ctx.setRealm(defaultRealm); 
       ctx.addLifecycleListener(new DefaultWebXmlListener()); 
       ContextConfig ctxCfg = new ContextConfig(); 
       ctx.addLifecycleListener(ctxCfg); 
       ctxCfg.setDefaultWebXml("org/apache/catalin/startup/NO_DEFAULT_XML"); 
       if (host == null) { 
           getHost().addChild(ctx); 
       } else { 
           host.addChild(ctx); 
       } 
       return ctx; 
}

```

一个web应用对应一个Context容器,也就是Servlet运行时的Servlet容器,添加一个web应用时将会创建一个StandardContext容器,并且给这个Context容器设置必要的参数,url和path分别代表这个应用在Tomcat中的访问路径和这个应用实际的物理路径,这两个参数与第一段代码中的地址是一样的.其中最重要的一个配置是ContextConfig,这个类会将负责整个Web应用配置的解析工作,最后将这个Context容器添加到Host中.

接下来会调用Tomcat的start方法启动Tomcat,Tomcat的启动逻辑是基于观察者模式设计的,所有的容器都会继承lifecycle接口,它管理容器的整个生命周期,所有容器的修改和状态的改变都会去通知已经注册的观察者(Listener).


![image](https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image003.jpg)

上图描述了Tomcat启动过程中,主要类之间的时序关系,下面我们重点关注添加examples应用对应的StandardContext容器的启动过程.

当Context容器初始化未init时,添加Context容器的Listener将会被调用.ContextConfig继承了LifecycleListener接口,它是在调用 Tomcat.addWebapp 时被加入到StandardConext容器中.ContextConfig类会负责整个Web应用的配置文件解析工作.

ContextConfig的init方法将完成以下工作:

1. 创建用于解析xml文件的contextDigster对象
2. 读取默认context.xml配置文件,如果存在解析它
3. 读取默认Host配置文件,如果存在解析它
4. 读取默认Context自身配置文件,如果存在解析它
5. 设置Context的DocBase


ContextConfig的init方法完成后,Context容器会会执行startInternal方法,这个方法启动逻辑比较复杂,主要包括如下几个部分:

1. 创建读取资源文件的对象
2. 创建ClassLoader对象
3. 设置应用的工作目录
4. 启动相关的辅助类如:logger,realm,resource
5. 修改启动状态,通知感兴趣的观察者(web应用的配置)
6. 子容器的初始化
7. 获取ServletContext并设置必要的参数
8. 初始化"load on startup"的Servlet



![image](http://7xpuj1.com1.z0.glb.clouddn.com/1.png)


###  servlet 接口定义

```

public interface Servlet{
   
    public void init(ServletConfig config ) throws SevletException;
    
    public ServletConfig getServletConfig();
    
    public void service(ServletRequest req,ServletResponse re) throws ServletException ,IOException;
    
    public String getServletInfo();
    
    public void destoy();

}

```

###  init 方法调用时会接收SerletConfig 类型的参数，在web.xml中定义Servlet 时配置的参数就是通过ServletConfig来保存的。

``` 

public interface SevletConfig{
  public String getSerlvetName();
  
  public ServletContext getServletContext();
  
  public String getInitParameter(String name);
  
  public Enumeration<String> getInitPaameterNames()

}

```

- getSevletName 获取Sevlet 的名字，也就是在web.xml中定义的Servlet-name;getInitparameter方法获取init-param 配置的参数；getServletContext 返回这个应用本身，其实就是Tomcat 中的Context 的门面类ApplicationContextFacade,在其中设置的参数就可以被所有Servlet共享了。

- ServletConfig是Sevlet级的，而SevletContext 是Context级的。

- context-param 配置的ContextConfigLocation 配置到了ServletContext中，而通过init-paam 配置的contextConfigLocation 配置到了SevletConfig中。
- 


###  另外，servletContext中非常常用的用法是保持Application级别的属性。可以用setAttribute来完成。


---

###  GeneicServlet 是Servlet 的默认实现，主要功能是：

- 实现了SevletConfig 接口，我们可以直接调用SevletConfig里面的方法
- 提供了无参Init方法
- 提供了log方法。

---

HttpSevlet 是用HTTP协议实现的Servlet的基类，写servlet的时候，直接继承它就可以了，不需要从头实现Servlet接口。
Httpservlet主要重写了Service方法，在service 方法中首先将ServletRequest,ServletResponse转换为了HttpSevletREquest和HttpServletResponse，然后根据Http 请求将请求路由到了不同的处理方法。


--- 

转发至:https://www.ibm.com/developerworks/cn/java/j-lo-servlet/ 
总结至：《看透springMVC源代码分析与实践》 作者：韩路彪,
