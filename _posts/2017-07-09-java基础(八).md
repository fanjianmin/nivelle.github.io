---
layout: post
title:  "java基础(八)"
date:   2017-06-10 00:06:05
categories: java
tags: java
excerpt: java
author: nivelle
---

### 异常


#### 概念

使用异常所带来的一个相当的明显好处是，它往往能够降低错误处理代码的复杂度。如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方处理它。而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误。并且，只需要在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节省代码，而且把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。

#### 基本异常

当异常出现并抛出时，首先java会通过new 在堆上创建对象，然后，从当前的执行路径(它不能继续下去了)被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。

- 异常使得我们可以将每件事当做一个事务考虑，而异常可以看护着这些事务的底线。
- 异常可以视为一种内建的恢复系统，因为我们在程序中可以拥有各种不同的恢复点。如果程序某部分失败了，异常将“恢复”到程序中某个已知的稳定点上。

异常最重要的方面之一就是如果发生问题，它们将不允许程序沿着其正常的路径继续走下去。

异常允许我们强制程序停止运行，并告诉我们出现了什么问题，或者(理想状态下)强制程序处理问题，并放回到稳定状态。

#### 异常参数

所有标准异常类都有两个构造器：一个默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：

```
throw new NullPointerException("t=null");

```
在使用new创建了异常对象之后，此对象的引用将传给throw。尽管返回的异常对象其类型不同，但从效果看，就像从方法“返回”的。(1) 可以简单地把异常处理看成一种不同的返回机制(2)抛出异常的方式还能从当前域退出。**这两种情况下，将返回一个异常对象，然后退出方法或作用域。**

---

### 捕获异常

#### try块

如果在方法内部抛出了异常(或者在方法内部调用的其他方法抛出了异常)，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种(可能产生异常的)方法调用，所以称为try块。它是跟在try关键字之后的普通程序块：

```
try{
    //code that might generate exception  
}
```
有了异常处理机制，可以把所有动作都放在try块里，然后只需在一个地方捕获所有异常。这使得代码更清晰，因为完成任务的代码没有与错误检查的代码混在一起。

#### 异常处理程序

抛出的异常必须在某处得到处理。这个“地点”就是异常处理程序，而且针对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在try块之后，以关键字catch表示：

```
try{
    //code that might generate exception
}catch(Type1 id1){
    //handle exceptions of Type1
}catch(Type2 id2){
    //handle exceptions of Type2
}catch(Type3 id3){
    //handle exceptions of Type3
}

```

每个catch子句(异常处理程序)看起来就像是接收一个且仅接收一个特殊类型的参数的方法。

异常处理程序必须紧跟在try块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch子句执行，此时认为异常得到了处理。一旦catch子句结束，则处理程序程序的查找过程结束。只有匹配的catch子句才能得到执行。

#### 终止与恢复

异常处理理论上有两种基本模型。

- 终止模式：假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。
- 恢复模式：异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。想要用java实现类似恢复行为，那么在遇见错误时就不能抛出异常，而是调用修正方法来修正该错误。或者，把try块放在while循环里，这样就不断地进入try块，直到得到满意的结果。
