---
layout: post
title:  "之GC回收算法"
date:   2017-11-25 01:06:05
categories: jvm
tags: GC回收算法
excerpt: GC回收算法
---

## 三大基础GC算法

#### 标记清除法/标记压缩法

标记清除（Mark and Sweep）:它的原理非常简单，首先从根开始将可能被引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png)

1. 部分显示了随着程序的运行而分配出一些对象的状态，一个对象可以对其他的对象进行引用。
2. 部分中，GC开始执行，从根开始对可能被引用的对象打上“标记”。大多数情况下，这种标记是通过对象内部的标志（Flag）来实现的。于是，被标记的对象我们把它们涂黑。
3. 部分中，被标记的对象所能够引用的对象也被打上标记。重复这一步骤的话，就可以将从根开始可能被间接引用到的对象全部打上标记。到此为止的操作，称为标记阶段（Mark phase）。
4. 部分中，将全部对象按顺序扫描一遍，将没有被标记的对象进行回收。这一操作被称为清除阶段（Sweep phase）。在扫描的同时，还需要将存活对象的标记清除掉，以便为下一次GC操作做好准备。标记清除算法的处理时间，是和存活对象数与对象总数的总和相关的。

作为标记清除的变形，还有一种叫做标记压缩（Mark and Compact）的算法，它不是将被标记的对象清除，而是将它们不断压缩。

#### 复制收集算法

标记清除算法有一个缺点，就是在分配了大量对象，并且其中只有一小部分存活的情况下，所消耗的时间会大大超过必要的值，这是因为在清除阶段还需要对大量死亡对象进行扫描。复制收集（Copy and Collection）则试图克服这一缺点。在这种算法中，会将从根开始被引用的对象复制到另外的空间中，然后，再将复制的对象所能够引用的对象用递归的方式不断复制下去。

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E8%B5%8B%E5%80%BC%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png)

（1）部分是GC开始前的内存状态，这和图1的（1）部分是一样的

（2）部分中，在旧对象所在的“旧空间”以外，再准备出一块“新空间”，并将可能从根被引用的对象复制到新空间中。

（3）部分中，从已经复制的对象开始，再将可以被引用的对象像一串糖葫芦一样复制到新空间中。复制完成之后，“死亡”对象就被留在了旧空间中。

（4）部分中，将旧空间废弃掉，就可以将死亡对象所占用的空间一口气全部释放出来，而没有必要再次扫描每个对象。下次GC的时候，现在的新空间也就变成了将来的旧空间。

和标记相比，将对象复制一份所需要的开销则比较大，因此在“存活”对象比例较高的情况下，反而会比较不利。这种算法的另一个好处是它具有局部性（Lo-cality）。在复制收集过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间中的可能性会提高，这被称为局部性。局部性高的情况下，内存缓存会更容易有效运作，程序的运行性能也能够得到提高。

#### 引用计数法

引用计数（Reference Count）方式是GC算法中最简单也最容易实现的一种，它和标记清除方式差不多是在同一时间发明出来的。它的基本原理是，在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间点。当一个对象的引用计数变为0时，则说明它将来不会再被引用，因此可以释放相应的内存空间。

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png)

(1）部分中，所有对象中都保存着自己被多少个其他对象进行引用的数量（引用计数），图中每个对象右上角的数字就是引用计数
（2）部分中，当对象引用发生变化时，引用计数也跟着变化。在这里，由对象B到对象D的引用失效了，于是对象D的引用计数变为0。由于对象D的引用计数为0，因此由对象D到对象C和E的引用数也分别相应减少。结果，对象E的引用计数也变为0，于是对象E也被释放掉了。图3的
（3）部分中，引用计数变为0的对象被释放，“存活”对象则保留了下来。大家应该注意到，在整个GC处理过程中，并不需要对所有对象进行扫描。

[转发至](https://segmentfault.com/a/1190000004665100)
