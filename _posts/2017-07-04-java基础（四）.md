---
layout: post
title:  "java基础(四)"
date:   2017-06-10 00:06:05
categories: 技术
tags: java
excerpt: java
author: nivelle
---

### 初始化与清理

#### 用构造器确保初始化

在java中，通过构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。

考虑命名：

- 取名不能与类的某个成员名称冲突
- 调用构造器是编译器的责任，所以必须让编译器知道应该调用那个方法。

考虑到在初始化期间要自动调用构造器，所以采用与类名称相同的构造器名就顺理成章了。

再调用new Rock() 将会为对象分配存储空间，并调用相应的构造器。这就确保了你能操作对象之前，它已经被恰当地初始化了。


构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空(void)明显不同。对于空返回值，尽管方法本身不会返回什么，但任可选择让它返回别的东西。构造器则不会返回任何东西，别无选择(new表达式确实返回了对新建对象的引用，但构造器本身并没有返回任何值)

#### 方法重载

为了让方法名相同而形式参数不同的构造器同时存在，必须用到方法重载。

区分方法重载：每个重载方法都必须有一个独一无二的参数类型列表。

##### 涉及基本类型的重载

如果传入的数据类型(实际参数类型)小于方法声明中的形式参数类型，实际数据类型就会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char提升到int。其他都是一级一级的提升。

有时并不关心返回值，你想要的是方法调用的其他效果（为了副作用而调用），这时你可能会调用方法而忽略其返回值。因此，通过返回值来区分重载方法是行不通的。

#### 默认构造器

如果写的类中没有构造器，则编译器会自动创建一个默认构造器，无参构造器。如果已经定义了一个构造器(无论是否有参数)，编译器就不会帮你自动创建默认构造器。

### this 关键字

为了能简单、面向对象的语法来编写代码————即"发送消息给对象”,编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给方法。

假设你希望在方法内部获得对当前对象的引用。由于这个是由编译器“偷偷”传入的，所以没有标识符可用。但是，专门有一个关键字：this。 this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。
---

但要注意：如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。**当前方法中的this引用会自动应用于同一类中的其他方法。**
```
public class Apricot{
    void pick(){}
    void pit(){oick();}
}
```
在pit()内部，你可以写this.pick(),但无此必要。编译器会自动添加。自由明确需要显示当前对象的引用的时候，才使用this关键字。比如需要返回当前引用，进行连续调用。

---

### 在构造器中使用构造器

可能为了一个类谢了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。使用this可以做到这一点，

通常写this的时候，都是指“这个对象”或者"当前对象"，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就意味着对符合此参数列表的某个构造器的明确调用。

可以用this调用一个构造器，但却不能调用两个，此外，必须将构造器调用置于最起始处，否则编译器会报错。

###  清理：终结处理和垃圾回收

为类清理费使用new获得的特殊内存区域，java允许在类中定义一个名为finalize()的方法。它的工作原理是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。

之所以有finalize(),是由于在分配内存时可能采用了类似C语言的做法，而非java中的常用做法。可能是java调用了本地方法，本地方法是一种在java中调用非java代码的方法。

```
如果Java虚拟机并未面临内存消耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。
```

### 成员初始化

- 方法局部变量


所有变量在使用前都能得到恰当的初始化。对于**方法的局部变量**，java以编译时错误的形式来贯彻这种保证。

```
void f(){
    int i;
    i++;//Error -- i not initialized
}
```
- 成员变量

要是类的数据成员(即字段)是基本类型，情况就会变得有些不同，类的每个基本类型数据成员保证都会有一个初始值。其中char值为0，所以就显示空白。在类里定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊值null。

#### 指定初始化

在定义类成员变量的地方为其赋值，也可以用同样的方法初始化非基本类型的对象，甚至可以通过调用某个方法来提供初值。

### 构造器初始化

可以调用构造器来进行初始化，在运行时刻，可以调用方法或执行某些动作来确定初值，这位编程带来了更大的灵活性。但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。

#### 初始化顺序

在类的内部，变量定义的先后顺序决定了初始化顺序。即使变量定义散布于方法定义之间，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。

#### 静态数据的初始化

无论创建多少个对象，静态数据都只占用一份存储区域。static关键字不能应用于局部变量，因此它只能作用于域。如果一个域是静态的基本类型域，且也没有对它进行初始化，那么它就会获得基本类型的标准初值；如果它是一个对象引用，那么它的默认初始化值就是null。

初始化的顺序是先静态对象（如果他们尚未因前面的对象创建过程而被初始化），而后是“非静态”对象。
