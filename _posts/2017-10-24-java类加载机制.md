---
layout: post
title:  "类加载机制"
date:   2017-10-23 00:06:05
categories: 技术
tags: ClassLoader
excerpt: java类加载机制
---


* content
{:toc}


### 定义

一个Java程序想要运行起来,首先要经过编译生成.class文件,然后创建一个运行环境(Jvm)来加载字节码文件到内存运行,而.class文件时怎样呗加载进jvm中的就是java Classloader所做的事情.

比如执行new 操作时,当执行Class.forName("包路径+类名"),Class.forName("包路径+类名",classLoader),classloader.loadclass("包路径+类名")时就触发了类加载器加载对应的路径去查找对应的路径去查找*.class,** 并创建Class对象.**

### java自带的ClassLoader

####  BootstrapClassloader

引导类加载器,又称启动类加载器,是最顶层的类加载器,主要用来加载java核心类,如rt.jar,resource.jar,charsets.jar等,Sun的JVM中,执行java的命令中石油-Xbootclasspath 选项或使用-D选项指定sun.boot.class.path系统属性值可以指定附加的类,它不是java.lang.ClassLoader的子类,而是由JVM自身实现的该类C语言实现,java程序访问不到该加载器,同过下面代码可以查看该加载器加载了哪些jar包.

```
public void test() {  
        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();    
        for (int i = 0; i < urls.length; i++) {    
            System.out.println(urls[i].toExternalForm());    
        }   
    }

```
执行结果:

```
file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/resources.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/rt.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/sunrsasign.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jsse.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jce.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/charsets.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/jfr.jar

file:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/classes，


```

#### ExtClassloader

拓展类加载器,主要负责加载Java的拓展类库,默认加载JAVA_HOME/jre/lib/ext/目下的所有jar包或者由java.ext.dirs系统属性指定的jar包.放入这个目录下的jar包对所有AppClassLoader都是可见的.那么ext都是在那些地方加载类的:

```
System.out.println(System.getProperty("java.ext.dirs"));

```

```
/Users/zhuizhumengxiang/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java

```

#### AppClassloader

系统类加载器,又称引用加载器,本文说的SystemClassloader和APPClassloader是一个东西,它负责在JVM启动时,加载来自在命令java中的-classpath或者java.class.path系统属性或者CLASSATH操作系统属性所指定的jar类包和类路径.调用ClassLoader.getSystemClassLoader()可以获得该类加载器.如果没有特别指定,则在用户自定义的任何类加载器都将该类加载器作为它的父加载器,这点通过ClassLoader的无参构造函数可以知道如下:

```
protected ClassLoader() {       

            this(checkCreateClassLoader(), getSystemClassLoader());
    }

```

执行以下代码即可获得classpath加载路径：

```

System.out.println(System.getProperty("java.class.
path"));
```

#### 三种类加载器的关系

![image](http://7xpuj1.com1.z0.glb.clouddn.com/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png)

用户定义的无参加载器的父类加载器默认是AppClassloader加载器,而AppClassLoader加载器的父加载器是ExtClassloader,通过下面代码可以验证:

```
ClassLoader.getSystemClassLoader().getParent()

```

一般我们都认为ExtClassloader的父类加载器是BootStrapClassloader,但是其实他们之间根本没有父子关系的,只是在ExtClassloader找不到加载类时回去委托BootStrao加载器区加载.通过如下代码可知父加载器为null:

```
ClassLoader.getSystemClassLoader().getParent().getParent()

```

#### 类加载器原理

java类加载器使用的是委托机制,也就是子类加载器在加载一个类的时候会让父类来加载.这样可以避免重复加载,当父亲已经加载了该类的时候,就没必要子ClassLoader再加载一次.考虑到安全因素,我们试想一下,如果不使用这种委托模式,哪我们就可以随时使用自定义的String来动态替代java核心api中定义的类型,这样会存在非常大的 安全隐患,而双亲委托的方式,就可以避免这种情况,因为String已经在启动时就被引导类加载器(BootStrap ClassLoader)加载,所以用户自定义的ClassLoader永远也无法加载一个自己写的String,除非你改变JDK中ClassLoader搜索类的默认算法.

```

protected Class<?> loadClass(Stringname,boolean resolve)  
       throws ClassNotFoundException  
   {  
       synchronized (getClassLoadingLock(name)) {  
           // 首先从jvm缓存查找该类
           Class c = findLoadedClass(name);  (1)           if (c ==null) {  
               longt0 = System.nanoTime();  
               try {  //然后委托给父类加载器进行加载
                   if (parent !=null) {  
                       c = parent.loadClass(name,false);  (2)
                   } else {  //如果父类加载器为null,则委托给BootStrap加载器加载
                       c = findBootstrapClassOrNull(name);  (3)
                   }  
               } catch (ClassNotFoundExceptione) {  
                   // ClassNotFoundException thrown if class not found  
                   // from the non-null parent class loader  
               }  

               if (c ==null) {  
                   // 若仍然没有找到则调用findclass查找
                   // to find the class.  
                   longt1 = System.nanoTime();  
                   c = findClass(name);  (4)                   // this is the defining class loader; record the stats  
                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 -t0);  
                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);  
                   sun.misc.PerfCounter.getFindClasses().increment();  
               }  
           }  
           if (resolve) {  
               resolveClass(c);  
           }  
           returnc;  
       }  
   }



````

分析代码知道首先会执行（1）从jvm缓存查找该类，如何该类之前被加载过，则直接从jvm缓存返回该类，否者看当前类加载器是否有父加载器，如果有的话则委托为父类加载器进行加载（2），否者调用（3）委托为BootStrapClassloader进行加载，如果还是没有找到，则调用当前Classloader的findclass方法进行查找。
从上面源码知道要想修改类加载委托机制，实现自己的载入策略 可以通过覆盖ClassLoader的findClass方法或者覆盖loadClass方法来实现。

#### Java中如何构造三种类加载器的结构

下面从源码来分析下JVM是如何构建内置classloader的，具体是rt.jar包里面sun.misc.Launcher类：


```

public Launcher()  
      {  
        ExtClassLoader localExtClassLoader;  
        try  
        {  //首先创建了ExtClassLoader
          localExtClassLoader = ExtClassLoader.getExtClassLoader();  
        }  
        catch (IOException localIOException1)  
        {  
          throw new InternalError("Could not create extension class loader");  
        }  
        try  
        {  //然后以ExtClassloader作为父加载器创建了AppClassLoader
          this.loader = AppClassLoader.getAppClassLoader(localExtClassLoader);  
        }  
        catch (IOException localIOException2)  
        {  
          throw new InternalError("Could not create application class loader");  
        }  //这个是个特殊的加载器后面会讲到，这里只需要知道默认下线程上下文加载器为appclassloader
        Thread.currentThread().setContextClassLoader(this.loader);  

        ................
      }



```

- ExtClassLoader.getExtClassLoader():

```

public Launcher()  
      {  
        ExtClassLoader localExtClassLoader;  
        try  
        {  //首先创建了ExtClassLoader
          localExtClassLoader = ExtClassLoader.getExtClassLoader();  
        }  
        catch (IOException localIOException1)  
        {  
          throw new InternalError("Could not create extension class loader");  
        }  
        try  
        {  //然后以ExtClassloader作为父加载器创建了AppClassLoader
          this.loader = AppClassLoader.getAppClassLoader(localExtClassLoader);  
        }  
        catch (IOException localIOException2)  
        {  
          throw new InternalError("Could not create application class loader");  
        }  //这个是个特殊的加载器后面会讲到，这里只需要知道默认下线程上下文加载器为appclassloader
        Thread.currentThread().setContextClassLoader(this.loader);  

        ................
      }


 ````
 

- 下面看下ExtClassLoader.getExtClassLoader()的代码

```

public static ExtClassLoader getExtClassLoader()  
      throws IOException  
    {  //可以知道ExtClassLoader类加载路径为java.ext.dirs
      File[] arrayOfFile = getExtDirs();  
      try  
      {  
        (ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction()  
        {  
          public Launcher.ExtClassLoader run()  
            throws IOException  
          {  
            int i = this.val$dirs.length;  
            for (int j = 0; j < i; j++) {  
              MetaIndex.registerDirectory(this.val$dirs[j]);  
            }  
            return new Launcher.ExtClassLoader(this.val$dirs);  
          }  
        });  
      }  
      catch (PrivilegedActionException localPrivilegedActionException)  
      {  
        throw ((IOException)localPrivilegedActionException.getException());  
      }  
    }  


    private static File[] getExtDirs()  
    {  
      String str = System.getProperty("java.ext.dirs");  
      File[] arrayOfFile;  
      if (str != null)  
      {  
        StringTokenizer localStringTokenizer = new StringTokenizer(str, File.pathSeparator);  

        int i = localStringTokenizer.countTokens();  
        arrayOfFile = new File[i];  
        for (int j = 0; j < i; j++) {  
          arrayOfFile[j] = new File(localStringTokenizer.nextToken());  
        }  
      }  
      else  
      {  
        arrayOfFile = new File[0];  
      }  
      return arrayOfFile;  
    }




```

- AppClassLoader.getAppClassLoader

```


public static ClassLoader getAppClassLoader(final ClassLoader paramClassLoader)  
      throws IOException  
    {  //可知AppClassLoader类加载路径为java.class.path
      String str = System.getProperty("java.class.path");  
      final File[] arrayOfFile = str == null ? new File[0] : Launcher.getClassPath(str);  

      (ClassLoader)AccessController.doPrivileged(new PrivilegedAction()  
      {  
        public Launcher.AppClassLoader run()  
        {  
          URL[] arrayOfURL = this.val$s == null ? new URL[0] : Launcher.pathToURLs(arrayOfFile);  

          return new Launcher.AppClassLoader(arrayOfURL, paramClassLoader);  
        }  
      });  
    }


```

总结下Java应用启动过程是首先BootstarpClassloader加载rt.jar包里面的sun.misc.Launcher类，而该类内部使用BootstarpClassloader加载器构建和初始化Java中三种类加载和线程上下文类加载器，然后在根据不同场景去使用这些类加载器去自己的类查找路径去加载类。


---

装载至:[技术原始积累](https://mp.weixin.qq.com/s?__biz=MzU2MTA1OTgyMQ==&mid=2247483679&idx=1&sn=60b1ed3cde67e49230d821b25429f50e&chksm=fc7fc39dcb084a8b998edd340c69c90dece4260e7ffae6b45dafd45d0ab6ac76949d186b7db8#rd)
