---
layout: post
title:  "线程池的使用"
date:   2017-07-01 00:06:05
categories: 多线程
tags: 线程池
excerpt: 线程池的使用
---


* content
{:toc}

###  ThreadLocal

背景：ThreadLocal是java语言提供的用于支持线程局部变量的标准实现类。它通过避免对象的共享，达到线程安全的目的。

虽然是通过ThreadLocal来设置特定于各个线程的数据资源，但ThreadLocal自身不会保存这些特定的数据资源。因为数据资源特定于线程，自然是由每个线程自己来管理了。每个Thread类都有一个ThreadLocal.ThreadLocalMap的实例变量，它就是保持那些通过ThreadLocal设置给这个线程的数据资源的地方。当通过Threadlocal的Set(data)方法设置数据的时候，ThreadLocal会首先获取当前线程的引用，然后通过该引用获取当前线程持有的threadLocals,最后，以当前ThreadLocal作为Key,将要设置的数据设置到当前线程，如下：

```
Thread thread = Thread.currentThrad();

ThreadLocalMap threadlocalmap = thread.threadLocals;
...
threadlocamap.set(this,obj);

```
余下的get()之类的方法：首先取得当前线程，然后根据每个方法的语义，也可以通过这个窗口获取绑定数据资源，当然，更可以解除之前绑定到当前线程的数据资源。在整个线程的生命周期内，我们都可以通过ThreadLocal这个窗口与当前线程大交道。

![image](http://7xpuj1.com1.z0.glb.clouddn.com/Threadlocal.png)

####  ThreadLocal的应用场景

 - 横向看，我们更注重于ThreadLocal横跨多个线程的能力，这是ThreadLocal最初的目的所在。为了以更加简单地方式来管理应用程序的线程安全，ThreadLocal干脆将没有必要共享的对象不共享，直接为每个线程分配一份各自特定的数据资源。

- 纵向看，我们则着眼于ThreadLocal在单一线程内可以发挥的能力，通过ThradLocal设置的特定于各个线程的数据资源，可以随着所在的线程执行流程“随波逐流”


---

- 管理应用程序实现中的线程安全：对于某些有状态或者非线程安全的对象，我们可以再多线程程序中为每个线程都分配相应的副本，而不是让多个线程共享该类型的某个对象，从而避免了需要协调多个线程对这些对象进行访问的“危险”工作。

在JDBC中，Connection对象属于有状态并且非线程安全的类。为了保证多个线程使用Connection进行数据访问过程中的安全，我们通过ThreadLocal为每个线程分配了一个他们各自持有的Connection,从而避免了对单一Connection资源的竞争。毕竟，在JDBC中是一个Connection对应一个事务。如果所有线程都公用一个Connection，事务管理就失控了。

- 实现当前程序执行流程内的数据传递。通过ThreadLocal来保存某种全局变量，在线程内执行流程的某个时点设置该全局变量，然后在合适的位置获取其值以做某些判断。只要愿意，任何合适的数据都可以通过ThreadLocal在单一线程内传递数据这一功能进行传递。
-  某些情况下的性能优化。本质上就是以空间换时间，避免不必要共享的对象共享。
-  per-thread Singleton.当某项资源的初始化代价较大，并且在整个执行流程中还会多次访问它的时候，为了避免在访问时每次都需要去初始化该项资源，我们可以在第一将该资源初始化完成之后，直接通过ThreadLocal将其绑定到当前线程，之后，所有对该资源的访问都从当前线程直接获取。

### 使用ThreadLocal管理多数据源切换的条件

思路：通过ThreadLocal保存每个数据源对应的标志（该标志我们以枚举形式给出），AbstractRountingDataSource在通过determineCurrentLookuoKey()获取对应数据源的键值得时候，直接从ThreadLocal获取当前线程所持有的数据源标志然后返回。而至于说什么情况下使用哪个具体的数据源问题，则是由应用层序的需求来决定，只要在必要的地方，将所要使用的具体数据源对应标志通过ThreadLocal绑定到当前线程即可。

流程如下：

(1) 假设有三个数据源可用，MAIN,INFO和DBLINK三个数据源可用。第一步给出个枚举类：
```
public enum DataSources{
    MAIN,INFO,DBLINK;
}

```
(2)定义所使用的ThreadLocal的DataSourceTypeManager类定义

```
public class DataSourceTypeManager{
    private static final ThreadLocal<DataSources> dsTypes = new ThreadLocal<DataSources>(){
        @Override
        protected DataSources initialValue(){
            return DataSources.MAIN;
        }
    }
    
    public static DataSources get(){
        return dsTypes.get();
    }
    
    public static void  set(DataSources DataSourceType){
        return dsTypes.set(DataSourceType);
    }
}


```

(3) 有了标志枚举类和相应的ThreadLocal定义之后，就可以实现我们的AbstractRountingDataSource了：

```
public class ThreadLocalVariableRountingDataSource extends AbstractRountingDataSource{
    @Override
    protected Object determineCurrentLookupKey(){
        return DataSourceTypeManager.get();
    }
}


```
(4)将相关配置注册到IoC容器。

```
<bean id="dataSource" class ="...ThradLcoalVariableRountingDataSource">
 <property name ="defaultTargetDataSource" ref=""/>
 <property name="targetDataSources"
   <map key-type="..DataSources">
     <entry key="MAIN" value-ref="mainDataSource"/>
     <entry key="INFO" value-ref=infoDataSource"/>
     <entry key="DBLINK" value-ref="dblinkDataSource"/>
   </map>

 </property>
</bean>

```
(5)我们可以使用如下代码是的数据源的切换生效：

```
DataSourceTypeNabager.set(DataSources.INFO);

或者

DataSourceTypeNabager.set(DataSources.DBLINK);

```

此后通过ThreadLocalVariableRountingDataSource所进行的数据访问，则会使用我们所设定的具体数据源。



## 线程池

![image](http://7xpuj1.com1.z0.glb.clouddn.com/executor.png)

###  线程池的大小

如果线程池过大，那么大量的线程将在相对很少的CPU和内存资源上发生竞争，这不仅导致更高的内存使用量，而且还可能耗尽资源。如果线程池过小，那么将导致许多空闲的处理器无法执行工作，从而降低吞吐量。

对于计算密集型的任务，在拥有N(cpu)个处理器的系统上，当线程池的大小为N+1时，通常能实现最优的利用率。对于包含IO操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。要正确地设置线程池的大小，你必须估算出任务的等待事件与计算时间的比值。

###  配置ThreadPoolExecutor

它为一些Executor提供了基本的实现，这些Executor是由Executors中的newCachedThreadPool,newFixedThreadPool和newScheduledThreadExecutor等工厂方法返回的。ThreadPoolExecutor是一个灵活的、稳定的线程池，允许进行各种定制。如果默认的执行策略不能满足需求，则可以根据情况自己定制。

```
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler){}

```

####  线程的创建与销毁

基本大小：Core Pool Size 也就是目标大小，即在没有任务执行时线程池的大小，*并且只有在工作队列满了的情况下才会创建超出这个数量的线程*。

最大大小：Maximum Pool Size 最大大小，表示可同时活动的线程数量的上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，*并且当线程池的当前大小超过了基本大小是，这个线程将被终止*。

通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占有的资源，从而使得这些资源可以用于执行其他工作。

newFixedThreadPool 工厂方法将线程的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。newCachedThreadPool工厂方法将线程池最大大小设置为Integer.MAX_VALUE，而将基本大小设置为零，并将超时设置为1分钟，这种方法创建出来的线程池可以被无限拓展，并且当需求降低是会自动收缩。其他形式的线程池可以通过显示的ThreadPoolExecutor。

####  管理队列任务

在有限的线程池中会限制可并发执行的任务数量、（单线程的Executor是一种值得注意的特例：它们能确保不会有任务并发执行，因为它们通过线程封闭来实现线程安全性）


ThreadPoolExecutor允许提供一个BlockingQueue来保存等待执行的任务。基本的任务排队方法有3类:无界队列，有界队列和同步移交。队列的选择和其他配置参数有关。

- newFixedThreadPool和newSingleThradExecutor在默认的情况下将使用一个无界的LinkedBlockingQueue。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。

一种更加稳妥的方式是使用有界队列，例如ArrayBlockingQueue、有界的LinkedBlickingQueue、PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况发生。

对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队，以及直接将任务从生产者移交给工作者线程。SynchrousQueue不是一个真正的队列，而是一种在线程之间进行移交的机制。将一个元素放入SynchrounousQueue中，必须有另一个线程在等待接受这个元素。如果没有线程等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutr将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。

只有当线程池是无界或者可以拒绝任务时，SynchronousQueue才有实际价值，在NewCachedThreadPool工厂方法中就使用了SynchronousQueue。
