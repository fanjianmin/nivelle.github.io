---
layout: post
title:  "java基础知识"
date:   2017-06-10 00:06:05
categories: 技术
tags: java
excerpt: java
author: nivelle
---


* content
{:toc}


#### 奇数性

java对取余操作(%)的定义产生的后果。该操作符被定义为对所有的int数值a和所有的非零数值b,都满足下面恒等式：

```
(a/b)*b+(a%b)==a
```
与java的截尾整数正常操作符号相结合时，意味着：当取余操作返回一个非零的结果时，它与做操作数具有相同的正负符号。

正确做法：

```
public static bolean isOdd(int i){
    return i%2 !=0;
}

```
或者：

```
pulic static boolean isOdd(int i){
    return (i&1)!=0
}
```

#### 找零

```
public class Change{
	public static void main(String args[]){
	  System.out.println(2.00-1.10);
	}
}
```

问题在于1.1这个数字不能被精确表示为一个double,因此被表示为最接近它的double值。然后2减去的就是这个值。

浮点运算在一个范围很广的值域上提供了很好的近似，但是通常不能产生精确的的结果。二进制浮点数对于货币计算是非常不合适的，因为它不可能将0.1或者10的其他任何次负幂，精确表示为一个有限长度的二进制小数。

**解决方法：**

- 解决该问题的一种方式是使用某种整数类型，例如int或long,并且以分为单位来执行计算。如果采纳了次路线,请确保该整数类型大到足以表示程序中将要用的所有值。

- 使用执行精确小数运算的BigDecimal。一定要用BigDecimal(String)构造器，而不使用BigDecimal(double)。后一个构造器将用它的参数的精确值来创建一个实例。例如new Bigdecimal(.1),它将返回一个BigDecimal,也即0.1000000000000000055511151231257827021181583404541015625
正确使用BigDecimal就可以正确打印出期望值0.90：

```
 System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10")));

```

注意：在需要精确答案的地方，要避免使用float和double；对于货币计算，要使用int、long或者BigDecimal。

####  长整除

被除数表示一天里的微妙数，而除数表示一天里的毫秒数：

```
public class LongDivision {
  public static void main(String[] args) {
    final long MICROS_PER_DAY=24*60*60*1000*1000;
    final long MILLIS_PER_DAY=24*60*60*1000;
    System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
  }
}
```
问题产生的原因：MICROS_PER_DAY的计算溢出了。虽然计算结果适合放入到long中，但是这个乘积并不适合放入int中。这个计算完全是以int运算来执行的，并且只有在运算完成之后，其结果才被提升为long.而此时已经太迟：计算已经溢出。从int提升为long是一种拓宽原生类型转换，他保留了不正确的数值。这个值之后被MILLIS_PER_DAY整除，而MILLIS_PER_DAY的计算是正确的，因为它适合int运算。

java不具有目标确定类型的特性，这时一种语言特性，其含义是指存储结果的变量类型会影响计算所使用的类型。

修正：

```
public class LongDivision {
  public static void main(String[] args) {
    final long MICROS_PER_DAY=24L*60*60*1000*1000;
    final long MILLIS_PER_DAY=24L*60*60*1000;
    System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
  }
}
```

当在操作很大的数字时，千万要防止溢出。即使用来保存结果的变量已经足够大，也不意味着要产生结果的计算具有正确的类型。

#### 初级问题

在long类型字面量中，一定要用大写的L,千万不要用小写的l。

#### 十六进制的趣事public class JoyOfHex {
  public static void main(String[] args) {
    System.out.println(Long.toHexString(0x100000000L +0xcafebbe));
  }
}


```
public class JoyOfHex {
  public static void main(String[] args) {
    System.out.println(Long.toHexString(0x100000000L +0xcafebbe));
  }
}


```
十进制字面量都是正的，而十六进制或是八进制字面量并不具备这个属性。如果十六进制和八进制字面量的最高为被置位了，所以它是一个负数。该程序执行的加法是混合类型的计算：左操作数是long类型，而右操作数是int。为了执行计算，java将int类型的数值用拓宽原生类型转换提升为long类型，然后对两个long类型数值相加。因为int是有符号的整数类型，所以这个转换执行的符号拓展：它将负的int类型数值提升为一个在数值上相等的long类型数值，然后对两个long类型数值相加。因为int是有符号的整数类型，所以这个转换执行的是符号拓展：它将负的int类型数值提升为一个在数值上相等的long类型数值。


解决方法：

避免混合类型的计算。


#### 多重转型




















---

内容来自《java解惑》 作者：布洛赫
